Uz jēdzieniem, kuri aprakstīti dotajā nodaļā tiks balstīta izstrādājamā kaudzes atkļūdošanas metode.
Šeit ir ietverti 2 svarīgākie jēdzieni: atmiņas izmete un kaudze.

 \section{Par atmiņas izmeti}
 Šajā sadaļā tiek aplūkots atmiņas izmetes jēdziens, ka arī aprakstītas atmiņas izmetes ģenerēšanas iespējas un nosacījumi.
Sadaļā ir aprakstīts atkļūdošanas process, kas var būt paveikts, izmantojot atmiņas izmeti.

 \subsection{Atmiņas izmetes ģenerēšana}
Sistēmās, kuras atbalsta POSIX standartus, ir signāli \cite{USP}, kuri, pēc noklusētās apstrādes, izraisa atmiņas izmetes ģenerēšanu un pārtrauc procesa darbību. 
Šos signālus var atrast  \texttt{man 7 signal} komandas izvadā. 
Signāliem, kuri izraisa izmetes ģenerēšanu, signālu tabulā \cite{signal} ir lauks ar vērtību core, kas atrodas ailē ar nosaukumu darbība (Action). 
Uzģenerētā atmiņas izmete iekļauj sevī procesa atmiņas attēlojumu uz procesa pārtraukšanas brīdi, piemēram, CPU reģistrus un steka vērtības katram pavedienam, globālos un statiskos mainīgos. 
Atmiņas izmeti var ielādēt atkļūdotājā, tāda kā gdb, lai  apskatītu programmas stāvokli uz brīdi, kad atnāca operētājsistēmas signāls \cite{core}.
Veicot atmiņas izmetes analīzi, kļūst iespējams atrast un izlabot kļūdas, pat tad, ja nav tiešas piekļuves sistēmai. 

Reālajās sistēmās atmiņas izmetes tiek uzģenerētas atmiņas kļūdu dēļ. 
Dažas no kļūdām sīkāk ir aprakstītas \ref{sec:problems} sadaļā. 
Bet eksistē vairākas iespējas kā atmiņas izmeti var uzģenerēt patstāvīgi.
Tas varētu būt nepieciešams programmas atkļūdošanai.
Atmiņās izmeti var uzģenerēt no programmas koda,  gdb atkļūdotāja vai komandrindas interpretatora.
Turpmāk katra no iespējam tiks apskatīta sīkāk, lai atrastu piemērotāku veidu kā var uzģenerēt atmiņas izmeti, dotā darba veiktajām pētījumam.

\subsubsection{Atmiņas izmetes ģenerēšana no koda}
Ģenerējot atmiņas izmeti no programmas koda, ir divas iespējas: process var turpināties vai beigt savu darbību pēc signāla nosūtīšanas.
\begin{figure}[h]
\begin{lstlisting}
#include <signal.h>

int main ()  {
    raise(SIGSEGV); /* Signal for Invalid memory reference */
	
    return 0;
}
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes ģenerēšana, pārtraucot procesa darbību}}}
\end{figure}

Ja nav nepieciešams, lai process turpinātu darbību, tad var izmantot funkcijas raise(), abort(), kā arī var apzināti pieļaut kļūdu kodā.
Tāda kļūda kā dalīšana ar nulli nosūta SIGFPE signālu, bet vēršanās pēc null radītāja - SIGSEGV signālu.
Izmantojot funkciju raise(), ir iespējams norādīt atmiņas izmeti izraisošo signālu.
Piemērā (sk. 1.1. attēlu) ir redzams C kods, kur funkcija raise() nosūta SIGSEGV signālu izpildāmai programmai. 
Pēc šī izsaukuma izpildes tiek izvadīts ziņojums: Segmentation fault (core dumped).
Atmiņas izmeti lietotāju procesiem var atrast darba mapē, jo Linux operētājsistēmā tā ir noklusēta atmiņas izmetes atrašanas vieta, bet noklusētais atmiņas izmetes nosaukums ir core.
\begin{figure}[h]
\begin{lstlisting}
 #include <stdlib.h>

 int main () {
     int child = fork();
     if (child == 0) {
         abort(); /* Child */
     }
     return 0;
 }
 \end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes ģenerēšana, turpinot procesa darbību}}}
\end{figure}

Ir iespējams uzģenerēt atmiņas izmeti, nepārtraucot procesa darbību (sk. 1.2. attēlu). 
To var panākt ar fork() funkcijas palīdzību. Funkcija fork() izveido bērna procesu, kas ir vecāka procesa kopija.
Funkcija fork(), veiksmīgas izpildes gadījumā, bērnu procesam atgriež 0 vērtību. 
Pēc abort() funkcijas izpildes, bērns beidz izpildi un uzģenerē atmiņas izmeti. Vecāks process turpina izpildi.

\subsubsection{Atmiņas izmetes ģenerēšana no gdb}

Atmiņas izmetes ģenerēšanas nolūkam var izmantot gdb komandas: \texttt{generate-core-file [file]}(sk. 1.3. attēlu) vai \texttt{gcore [file]}. Šīs komandas izveido gdb pakļautā procesa atmiņas izmeti. 
Izmantojot gdb, var uzģenerēt atmiņas izmeti, kura atbilst kādam pārtraukuma punkta stāvoklim. 
Neobligāts arguments \texttt{filename} nosaka atmiņas izmetes nosaukumu. Šī gdb komanda ir realizēta GNU/Linux, FreeBSD, Solaris un S390 sistēmās \cite {gdb_gen_core}.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) attach <pid>
(gdb) generate-core-file <filename>
(gdb) detach
(gdb) quit
 \end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes ģenerēšana, izmantojot gdb}}}
\end{figure}

\subsubsection{Atmiņas izmetes ģenerēšana no komandrindas interpretatora}
Trešā iespēja ir nosūtīt signālu, izmantojot komandrindas interpretatoru. 
Komanda kill var nosūtīt jebkuru signālu procesam.
Pēc komandas  \texttt{kill -<SIGNAL\_NUMBER> <PID>}, signāls ar numuru  SIGNAL\_NUMBER tiks nosūtīts procesam ar norādītu PID vērtību.
Izmantojot shell komandrindas interpretatoru ir  iespējams izmantot īsinājumtaustiņus signālu nosūtīšanai. 
Nospiežot Control + $\backslash$ tiks nosūtīts SIGQUIT signāls procesam, kas pašreiz ir palaists (sk. 1.4. attēlu) \cite {nosacijumi}. 
Šajā piemēra ziņojumu - Quit (core dumped), izdruka shell. 
Šīs komandrindas interpretators noteic, ka  sleep procesu (shell bērnu) pārtrauca SIGQUIT signāls. 
Pēc šī signāla nosūtīšanās, darba mapē tiek uzģenerēta atmiņas izmete. 

\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
$ ulimit –c unlimited
$ sleep 30
Type Control + \
^\Quit (core dumped)
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes ģenerēšana, izmantojot īsinājumtaustiņus}}}
\end{figure}
  
\subsection{Atmiņas izmetes ģenerēšanas nosacījumi}
Lai  uzģenerētu atmiņas izmeti ir jābūt izpildītiem sekojošiem nosacījumiem \cite {nosacijumi}:
%\vspace{-6pt}
\begin{itemize}
	\item   ir jānodrošina atļauja procesam rakstīt atmiņas izmeti darba mapē;
	\item 	ja datne, ar vienādu nosaukumu jau eksistē, tad uz to ir jābūt ne vairāk kā vienai stingrai saitei;
	\item 	izvēlētai darba mapei ir jābūt reālai un jāatrodas norādītajā vietā;
	\item 	Linux core datnes izmēra robežai {RLIMIT\_CORE} jāpārsniedz ģenerējamā faila izmēru, { RLIMIT\_FSIZE} robežai jāļauj procesam izveidot atmiņas izmeti;
	\item 	ir  jāatļauj lasīt bināro datni, kura ir palaista;
	\item 	failu sistēmai, kurā atrodas darba mape, ir jābūt uzmontētai priekš rakstīšanas, tai nav jābūt pilnai un ir jāsatur brīvie indeksa deskriptori;
	\item 	bināro datni jāizpilda lietotājam, kurš ir datnes īpašnieks (group owner).
\end{itemize} 
 
 Pēc noklusējuma atmiņas izmetes ģenerēšanas iespēja ir izslēgta,  \texttt{ulimit -c unlimited} komanda ļauj ieslēgt atmiņas izmetes ģenerēšanu.

\subsection{Atkļūdošana, izmantojot atmiņas izmeti}
Atmiņas izmete satur datus, kuri dod iespēju atrast kļūdas. Tāpēc atmiņas izmete var tikt pielietota, lai veiktu lietotnes atkļūdošanu, pēc neparedzētas programmas apstāšanās.
Atmiņas izmetes analīze ir efektīvs veids, kā var attālināti atrast un izlabot kļūdas bez iejaukšanās un tiešas piekļuves sistēmai.
Daudzos gadījumos, atmiņas izmete ir speciāli uzģenerēta datne, kura palīdz iegūt atmiņas stāvokli uz signāla nosūtīšanas brīdī.
Atmiņas izmete ir labi piemērota kļūdu meklēšanai, kas saistītas ar nepareizo atmiņas izmantošanu lietotnē.

Atmiņas izmete ir ELF, a.out vai cita formātā binārā  datne. 
ELF formāts ir Linux un Unix standarts priekš izpildāmām datnēm, objektu datnēm, bibliotēkām un atmiņas izmetēm.
Lai darbotos ar atmiņas izmetem ir nepieciešams, lai rīks, kurš tika izvēlēts (bibliotēka, utilītprogramma vai atkļūdotājs) atbalstītu uzģenerētās datnes formātu.
GNU gdb ir  Linux standarta atkļūdotājs \cite{MWMK}, kurš ir plaši pielietojams atmiņas izmešu analīzei. 
Turpmāk tiek apskatīta atmiņas izmetes analīze ar gdb atkļūdotāja palīdzību.

\subsubsection{Atmiņas izmetes atkļūdošana, izmantojot gdb }
 \label{subsec:debugg_gdb}
Ja atmiņas izmetes analīzei tika izvēlēts GNU gdb atkļūdotājs, tad pirms sākt analīzi ir nepieciešams pārliecināties ka gdb ir pareizi nokonfigurēts priekš procesora arhitektūras, no kuras bija iegūta atmiņas izmete.
To var identificēt uzreiz pēc gdb palaišanas, ar sekojošās rindiņas palīdzību: \texttt{This GDB was configured as i686-linux-gnu}.  
Lai atmiņas izmete saturētu atkļūdošanas informāciju, ir jānorāda -g opcija kompilācijas laikā.
Atkļūdošanas informācija ir uzglabāta objektu datnē un saglabā atbilstību starp izpildāmo datni un pirmkodu, ka arī uzglabā mainīgo un funkciju datu tipus.
Ja atmiņas izmete neiekļauj atkļūdošanas informāciju, tad atmiņas izmete var izdrukāt sekojošo tekstu (sk. 1.5. attēlu).

\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) p main
$ 1 = {<text variable, no debug info>} 0x80483e4 <main>
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmete nesatur atkļūdošanas informāciju}}}
\end{figure}

Kad atmiņas izmete ir uzģenerēta, tad to var apskatīt, izmantojot gdb atkļūdotāju (sk. 1.6. attēlu). 
Atkļūdotājam kā argumenti tiek padoti: izpildāms fails un atmiņas izmete. 
Izpildāmam failam ir jāatbilst atmiņas izmetei, lai varētu apskatīt korektus, nesabojātus datus.

\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
$ gdb <path/to/the/binary> <path/to/the/core>
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes atvēršana, izmantojot gdb atkļūdotāju}}}
\end{figure}
%$

Gdb ļauj iegūt svarīgus datus no atmiņas izmetes. Komanda \texttt{info files} ļauj apskatīt procesa segmentus. 
Katram segmentam ir adrešu apgabals ar nosaukumu. 
Segmenti, kuru nosaukums ir "loadNNN" pieder procesam, tajos var tikt uzglabāti: statiskie dati, steks, kaudze, koplietošanas atmiņa.
Tā kā segmentu robežas ir zināmas, tad kļūst iespējams izdrukāt atmiņas saturu, kas pieder segmentiem un uzzināt kuram segmentam pieder nezināmā atmiņas adrese.

Lai izdrukātu atmiņas apgabalu var izmantot instrukciju ar sekojošo formātu: \texttt{x/nfu addr}. 
Ir nepieciešams norādīt atmiņas adresi (addr), no kuras sākt atmiņas izdruku, formātu (f), apgabala lielumu (n) un norādīt vienības lielumu (u). 
Izmantojot doto piemēru (sk. 1.7. attēlu), tiks izdrukāti 4 elementi, kuri pieder stekam, jo Intel x86 procesoros 32 bitu režīmā uz steku norāda \$esp reģistrs. 
Formātu un vienības lielumu vajag norādīt saskaņā ar gdb pamācību \cite{gdb}. 
Dotajā gadījumā atmiņa tiks izdrukāta heksadecimālā formātā (x) un vienības lielums ir vārds (word) jeb 4 baiti.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) x/4wx $esp
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas apgabala izdrukāšana}}}
\end{figure}

Lai uzzinātu kuram simbolam (funkcijai, mainīgam vai tipam) pieder adrese var izmantot sekojošo gdb instrukciju (sk. 1.8. attēlu) \cite{gdb}.
Instrukcija \texttt{print} vai \texttt{p} ļauj izdrukāt datus, bet \texttt{p/a} izdrukā absolūto adresi un relatīvo jeb adresi ar nobīdi no tuvāka simbola, kuram pieder adrese.
Tādā veidā var noteikt kuram atmiņas apgabalam pieder nezināmā adrese.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) p/a 0x54320
$3 = 0x54320 <_initialize_vx+396>
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Noteikšana, kuram simbolam pieder adrese}}}
\end{figure}

Atmiņas izmetes analīze sākas ar backtrace izdrukāšanu. 
Bactrace ir pārskats, kurš attēlo kā programma nonāca stāvoklī, kurā pabeidza savu darbību.
Tas palīdz ātri atrast instrukciju, kura bija izpildīta pēdēja un daudzos gadījumos, ļauj ātri identificēt kļūdas cēloņi.
Backrtace nesniedz patieso informāciju par funkciju, ja process tika pabeigts ārējo apstākļu dēļ, nevis tāpēc, ka bija notikusi kļūda programmā.
Katra rindiņa satur rāmi (frame). Bactrace izdruka sākas ar rāmi, kurā iekļauta funkcija, kura bija izpildīta pēdēja. 
Nākamais rāmis iekļauj funkciju, kas izsauca iepriekšējā rāmī iekļauto funkciju.
Katrai baktrace rindiņai tiek piešķirts rāmja numurs. Katrs rāmis var iekļaut: funkcijas nosaukumu, pirmkoda datnes nosaukumu, pirmkodam atbilstošo rindiņas numuru un funkcijas argumentus. 
Bactrace var tikt iegūts izmantojot gdb komandu \texttt{bactrace full} vai \texttt{bt f}. 
Pēc noklusējuma, daudzpavedienu lietotnēs gdb  rāda bactrace kārtējām pavedienam, bet pastāv iespēja iegūt arī bactrace izdruku priekš citiem pavedieniem.
Ja programma bija nokompilēta ar optimizācijas opciju, tad bactrace varētu neiekļaut funkcijas argumentus.
Šajā gadījumā funkciju argumenti varētu tikt nodoti caur CPU reģistriem, kuru vērtības ir iespējams iegūt, izmantojot komandu \texttt{info registers} vai \texttt{i r}.
Atmiņas izmetē atrodas pēdējais atmiņas stāvoklis, tāpēc CPU reģistru vērtības visticamāk tiks parakstītas.
 Ja ir nepieciešamība, tad reģistru vērtības ir iespējams atjaunot no steka.
 %ja pēc izjaukšanas (disassembling) ir redzams, ar cik lielu nobīdi tie tika saglabāti stekā.
%Izjaukšana (disassembling) ļauj izdrukāt asamblera instrukcijas noraidītai funkcijai. 
%Tas dod iespēju salīdzināt pirmkodu ar asamblera instrukcijām un tāda veidā kļūst iespējams atrast nepieciešamo mainīgo vērtības stekā.


%\subsubsection{Atmiņas izmetes pārbaude uz derīgumu}


%==========================================



\section{Atmiņas organizācija}

Šī sadaļa palīdz saprast kopējo atmiņas organizāciju un kaudzes\footnote{Šī termina nozīme atšķiras no datu struktūras "kaudze", kurā elementi tiek izvēlēti saskaņā ar to prioritāti.} lomu tajā. 
Šajā nodaļā ir aprakstīti atmiņas iedalīšanas paņēmieni, ir dots īss ieskāts GNU C bibliotēkas ptmalloc2 realizācijā un aprakstīta atmiņas pārvaldība.

\subsection{Atmiņas iedalīšanas paņēmieni}
%\label{sect:Motivation}

Pirms izpildīt programmu, operētājsistēmai ir nepieciešams iedalīt resursus, tādus kā atmiņas adreses.  
Eksistē divi atmiņas iedalīšanas paņēmieni: statiskā un dinamiskā atmiņas iedalīšana (sk. 1.9. attēlu). 

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.28]{alloc}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas iedalīšanas paņēmienu klasifikācija}}}
\label{fig:alloc}
\end{figure}


\subsubsection{Statiskā atmiņas iedalīšana}
Statiskā atmiņas iedalīšana nozīme, ka atmiņa tiek iedalīta pirms programmas palaišanas, parasti tas notiek kompilācijas laikā.
Programmas izpildēs laikā atmiņa vairs netiek iedalīta, ka arī netiek atbrīvota. 
Statiskais atmiņas iedalīšanas paņēmiens nodrošina to, ka atmiņa tiek iedalīta statiskiem un globāliem mainīgiem, neatkarībā no tā vai mainīgais tiks izmantots programmā pie dotajiem nosacījumiem vai nē.

\subsubsection{Dinamiskā atmiņas iedalīšana}
Dinamiskā atmiņas iedalīšana nozīme, ka atmiņa tiek iedalīta programmas izpildes laikā.
Tas var būt nepieciešams, kad atmiņas daudzums nav zināms programmas kompilācijas laikā. 
Dinamiskā atmiņas iedalīšana, var būt realizēta ar steka vai kaudzes palīdzību un var būt automātiskā vai kontrolētā \cite{SDMA}.

Automātiskā iedalīšana notiek, kad sākās programmas funkcijas izpilde. 
Priekš automātiskās atmiņas iedalīšanas, izmato steku.
Šeit viens un tas pats atmiņas apgabals, kurš bija atbrīvots, var tikt izmantots  vairākas reizēs. 
Piemēram, funkcijas argumenti un lokālie mainīgie ir saglabāti stekā un izdzēsti pēc šīs funkcijas izpildes. 
Pēc tam atbrīvotā atmiņa var būt izmantota atkārtoti. 
Vērtību izdzēšana vai saglabāšana notiek, nobīdot steka norādi.
Visiem funkcijas mainīgiem var piekļūt izmantojot steka norādes nobīdi, kas tiek uzglabāta reģistrā, piemēram,  
Intel x86 procesoros, 16 bitu režīmā tas ir reģistrs \texttt{SP}, 32 bitu režīmā - \texttt{ESP} un 64 bitu režīmā - \texttt{RSP} \cite{JCL}.


Kontrolētā atmiņas iedalīšana nozīme, ka programma izvēlās brīvus atmiņas gabalus no pieejama segmenta telpas, priekš programmas datiem. 
Kontrolētā jeb manuālā atmiņas iedalīšana parasti ir nodrošināta ar kaudzes palīdzību.
Šeit nav iespējams piekļūt visiem iedalītiem atmiņas gabaliem, izmantojot vienu norādi un tās nobīdi, piemēram, kā tas tiek nodrošināts stekā. 
Tagad katram iedalītam atmiņas gabalam var piekļūt tikai tad, ja ir norāde uz šo iedalīto atmiņas gabalu. 
Gadījumos, kad norādes nav, tad adreses vairāk nav sasniedzamas un kļūst pazaudētas.
Turpmāk darbā, termins "dinamiskā atmiņa" apzīmēs atmiņu, kura tiek iedalīta, izmantojot kontrolēto atmiņas iedalīšanu.


\subsection{Atmiņas pārvaldība}
Kad tiek izpildīta jebkura programma, atmiņa tiek pārvaldīta divos veidos: ar kodola palīdzību vai ar lietotnes funkciju izsaukumiem, tādiem kā malloc().

\subsubsection{Kodola atmiņas pārvaldība}
Operētājsistēmas kodols apstrādā visus atmiņas pieprasījumus, kas attiecās uz programmu vai programmas instancēm.
Kad lietotājs sāk programmas izpildi, tad kodols iedala atmiņas apgabalu tekošām procesam.
Šīs apgabals, no procesa viedokļa, ir viena lineārā virtuālā adrešu telpa, kura ir sadalīta vairākos segmentos. 
Svarīgākie procesa segmenti  \cite {PETRSOF}:
%\vspace{-20 pt}
\begin{itemize}
	\item   Teksta segments - šeit tiek uzglabāti dati, kuri tiek izmantoti tikai lasīšanai. Tās ir nokompilētas koda instrukcijas. 
    Vairākas programmas instances var izmantot šo atmiņas apgabalu;
    \item Statisko datu segments - apgabals, kurā tiek uzglabāti dati ar iepriekš zināmu izmēru. Tās ir globālie un statiskie mainīgie.
    Operētājsistēma iedala šī apgabala kopiju katrai programmas instancei atsevišķi;
    \item Kaudzes segments - apgabals, no kura tiek iedalīta dinamiskā atmiņa.
    Kaudzes segmentā atrodas dinamiski iedalītā un atbrīvotā atmiņa. Kaudzes segmenta saturs ir sadalīts sīkāk, mazākos atmiņās gabalos.
    Kaudzes segments aug no mazākas adreses līdz lielākai.  Lai palielinātu kaudzes segmenta izmēru, tiek veikts brk() sistēmas izsaukums. 
    Izsaukums uzstāda kaudzes segmenta jauno beigu robežu. 
 Jā process nepārsniedz savu limitu, tad izsaukums atgriež 0 un kaudzes segmenta lielums tiek veiksmīgi izmainīts, pretējā gadījumā tiek atgriezta vērtība -1 \cite{LINMAN};
    \item Steka segments - apgabals, kurā tiek uzglabāti: funkciju izsaukumu stāvoklis, katram funkcijas izsaukumam, ka arī lokālo mainīgo un reģistru vērtības. 
    Steks aug no lielākas adreses līdz mazākai. 
    Steks ir iedalīts priekš katras programmas instances atsevišķi.
     Iedalīto virtuālo adrešu karti var atrast \texttt{/proc/<pid>/maps} datnē.
\end{itemize} 

 
\subsubsection{Lietotāja atmiņas pārvaldība}
Atmiņa, kas var tikt dinamiski iedalīta, parasti ir novietota kaudzē. 
Lietotāja atmiņas pārvaldība ir dinamiskās atmiņas pārvaldība no lietotnes.
Lai nodrošinātu lietotāja atmiņas pārvaldību no lietotnes ir nepieciešams iedalītājs (allocator), kurš veic sistēmas izsaukumus un pārvalda iegūto atmiņu, sadalot to sīkākos gabalos.
Iedalītājs ļauj efektīvāk pārvaldīt atmiņu, nekā tas būtu nodrošināts, katru reizi pieprasot atmiņas gabalu ar sistēmas izsaukumiem.
Šobrīd eksistē vairāki iedalītāji, piemēram, Hoard memory allocator, ptmalloc2, dlmalloc.
Iedalītāju galvenie uzdevumi: 
\begin{enumerate}
\item sekot atmiņas gabaliem, kuri ir izmantoti;
\item sekot atbrīvotiem atmiņas gabaliem;
\item nodrošināt iespēju atkārtoti izmantot atmiņu.
\end{enumerate}
Dažreiz tiek izveidots individuālā iedalītāja risinājums. 
Kaut arī daži universālie iedalītāji strādā pietiekoši ātri un fragmentēšanas līmenis ir zems, individuālais risinājums var ņemt vērā lietotnei raksturīgas īpatnības un tās nodrošinās labāko veiktspēju \cite{EDBG}.
\begin{figure}[h]
\begin{lstlisting} [language=C++]
int * ptrl = new int; // C++
int * ptrl = (int *)malloc(sizeof(int)); /* C */

char * str = new char[num_elements]; // C++
char * str = (char *)malloc(sizeof(char) * num_elements); /* C */
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Dinamiskās atmiņas iedalīšana C un C++}}}
\end{figure}

GNU C bibliotēkā ir iebūvēts ptmalloc2 iedalītājs.
Turpmāk tiks apskatīta lietotāja atmiņas pārvaldība no lietotnes, izmantojot GNU C bibliotēkas funkciju palīdzību, ko nodrošina ptmalloc2.
C valodā dinamiskā atmiņa tiek pārvaldīta ar malloc(), realloc(), free() un calloc() funkciju palīdzību \cite {PETRSOF}.
C++ valodā ir izmantots operators new, lai pieprasītu atmiņu. 
Attēlā 1.10. ir redzama C un C++ sintakse atmiņas pieprasīšanai izmantojot C un C++ kodu.


Funkcija malloc() ir definēta malloc.c datnē GNU C bibliotēkā. 
Funkcijas prototips ir definēts <stdlib.h>.
Funkcija malloc() ļauj dinamiski iedalīt atmiņu procesam.
Vienīgais arguments malloc() funkcijai ir baitu skaits.
C programmai, lai saskaitītu cik baitu ir nepieciešams pieprasīt, ir nepieciešams zināt cik daudz vietas aizņem viens elements un kāds ir elementu skaits.
Funkcija malloc() atgriež void tipa rādītāju, tāpēc C programmās ir nepieciešams izmantot drošo tipa pārveidotāju (typecast). 
Tas ir nepieciešams, lai saglabātu atgriezto norādi lokālajā mainīgajā. Atmiņas inicializācija C kodā
var būt veikta izmantojot arī citas funkcijas, piemēram calloc() funkciju, kura atgriež atmiņas gabalu inicializētu ar 0 vērtībām.

Funkcija free() atbrīvo ar malloc() palīdzību iedalīto atmiņu.
Lielāka atšķirība starp free() un delete ir tāda, ka vecajās free() realizācijās netiek nodrošināts atbalsts free() funkcijai, kad arguments ir null \cite{POCF}. 

Programmas rakstīšanā nejauc kopā C un C++ stilus, tāpēc priekš C++ programmas izmanto 
new un delete operatorus (sk. 1.11. attēlu), bet priekš C programmām malloc() un free().
Ja atmiņa pēc izmantošanas netiek nekad atbrīvota, un katru reizi, izpildot vienu un to pašu koda gabalu, iedalīta no jauna, tad pieejams no operētājsistēmas atmiņas daudzums ar laiku samazinās.

\begin{figure}[h]
\begin{lstlisting}
delete ptrl; // C++

If(ptrl != NULL)
	free(ptrl); /* C */
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Dinamiskās atmiņas atbrīvošana C un C++}}}
\end{figure}


%Sākumā sistēma paliek arvien lēnāka, pēc tam parasti notiek sistēmas apstāšanās.


\subsection{Atmiņas organizācija glibc bibliotēkā}
Darbā tiek aplūkota GNU C bibliotēkas (versija 2.3) ptmalloc2 realizācija, kuru izstrādāja Wolfram Gloger, balstoties uz Doug Lea dlmalloc realizāciju. 
Atmiņas iedalīšana sākas ar malloc() vai līdzīgo funkciju izsaukumiem no programmas koda un tiek nodrošināta ar GNU C bibliotēkas palīdzību. 


\subsubsection{Atmiņas arēna}

Atmiņas arēnu var nosaukt par loģisko atmiņas kolekciju. Attēlā\footnote{Attēla izveidošanai tika izmantots GNU C malloc pirmkods \cite {MALLOC} un vietnē nopublicēta shēma \cite{AMM}. Attēls demonstrē atmiņas organizāciju.} 1.12. ir parādītas 3 arēnas, kuras ir atdalītas savā starpā ar raustītam līnijām.
 Atmiņas arēnu  vienkāršotā veidā var attēlot kā viensaišu saistīto sarakstu, kurš sastāv no vienas vai vairākām atmiņas kaudzēm. 
 Kaudze ir lineārās apgabals, kurš iekļauj sevī iedalītus un atbrīvotus atmiņas gabalus (chunk of memory), kuri ir novietoti blakus viens otram.
 Atmiņas gabali sīkāk ir aprakstīti \ref{subsec:atminas_gabali} sadaļā.
 \begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{threads}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas organizācija GNU C bibliotēkā (versija 2.3)}}}
\end{figure}
 Gadījumos, kad gabals ir iedalīts, tad pašreiz palaists process satur norādi uz iedalīto apgabalu kaudzē. 
 Ja gabals ir atbrīvots, tad tas tiek pievienots vienā no sarakstiem uz kuriem norāda bin masīvi, kuri atrodas vienā no arēnām.
Bin masīvs un bin saraksti sīkāk ir aprakstīti \ref{subsec:bin_saraksti} sadaļā. 
 Katrā arēnā ir rādītājs uz nākamo izveidoto arēnu. Pēdējā izveidotā arēna norāda uz galveno arēnu.
 Ja kārtēja kaudze ir izlietotā un tajā nav atmiņas, tad tiek iedalīta jauna kaudze ar fiksēto 64 MB izmēru.
  Tāda veidā arēnas var tikt paplašinātas, izveidojot jaunās kaudzes un savienojot tās sava starpā.
 Jaunai kaudzei ir norāde gan uz arēnu, kurai tā pieder, gan uz iepriekšējo kaudzi.

Lai uzlabotu veiktspēju vairākpavedienu procesiem, GNU C bibliotēkā tiek izmantotas vairākas atmiņas arēnas. 
Katrs funkcijas malloc() izsaukums bloķē arēnu, no kuras tiek pieprasītā atmiņa. 
Laikā, kad arēna ir nobloķēta, notiek atmiņas gabala iedalīšana.
Kad vairākiem pavedieniem ir nepieciešams vienlaicīgi iedalīt atmiņu no kaudzes un visi pavedieni mēģina piekļūt vienai un tai pašai arēnai (tas varētu notikt dlmalloc realizācijā), tad arēnas bloķēšana var būtiski samazināt veiktspēju.
Gadījumos, kad pavedieni izmanto atmiņu no vairākām atsevišķām arēnām (kā tas notiek ptmalloc2 realizācijā), tad vienas arēnas bloķēšana neietekmē atmiņas iedalīšanu parējās kaudzēs, kuras nepieder nobloķētai arēnai, un atmiņas iedalīšana var notikt paralēli.
Lai nodrošinātu labāku veiktspēju, GNU C bibliotēkā tiek izmantots modelis: katram pavedienam - viena arēna. 
Ja malloc() pirmo reizi izsaukts pavedienā, tad neatkarībā no tā vai kārtējā arēna bija nobloķēta vai nē, tiks izveidota jauna arēna.
Arēnu skaits ir ierobežots atkarībā no kodolu skaita, 32 bitu vai 64 bitu arhitektūras un mainīga MALLOC\_ARENA\_MAX vērtības.
Tā kā pavedienu skaits parasti nepārsniedz divkāršo kodolu skaitu, tad normālā gadījumā katrs pavediens izmanto atsevišķo arēnu. 
Darbība ar arēnām notiek saskaņā ar sekojošo algoritmu: 
\begin{enumerate}
\item malloc() izsaukums vēršas pie arēnas, kurai piekļuva iepriekšējo reizi;
\item ja arēna ir nobloķēta, tad malloc() vēršas pie nākamas izveidotās arēnas;
\item ja nav piekļuves nevienai arēnai, tad tiek izveidota jauna arēna un malloc() vēršas pie tās.
\end{enumerate}

Vispirms atmiņas iedalīšana sākas no galvenās arēnas (main arena). 
GNU C bibliotēkā ir globāls \texttt{malloc\_state} objekts - galvenā arēna, kura atšķiras no pārējām arēnām ar to, ka tā tiek paplašināta, izmantojot brk() nevis  mmap() sistēmas izsaukumu. 
Līdz ar galvēnās arēnas paplašināšanu, tiek paplašināts arī procesa kaudzes segments.
brk() sistēmas izsaukumam ir viens arguments, kurš uzstāda procesa kaudzes segmenta jaunas beigas.
mmap() sistēmas izsaukums paplašina pārējās dinamiskās arēnas daudzpavedienu lietotnēs, ka arī nodrošina lielu atmiņas bloku iedalīšanu mmap apgabalā.
Mazākais gabals, kurš pēc noklusējuma tiks iedalīts ar mmap(), ir vienāds ar 128 kilobaitiem. 
Sākot ar GNU C bibliotēkas 2.18 versiju, mazāko gabalu, kurš tiks iedalīts ar mmap() var uzdot ar M\_MMAP\_THRESHOLD konstanti.





 \subsubsection{Atbrīvotās atmiņas organizācija}
 \label{subsec:bin_saraksti}
Atbrīvots atmiņas gabals ne vienmēr tiks uzreiz atgriezts operētājsistēmai (sīkāk tas ir aprakstīts \ref{sec:peak_mem} sadaļā), bet var tikt defragmentēts vai sapludināts ar pārējiem gabaliem un ievietots sarakstā. 
Realizācijā ptmalloc2 ir masīvi, kuri uzglabā norādes uz bin sarakstiem.
Bin saraksti ir struktūras, kuras uzglabā atbrīvotus atmiņas gabalus, līdz brīdim, kad tie tiks iedalīti procesam atkārtoti.
Priekš sarakstiem netiek atsevišķi iedalīta atmiņa, bet tiek izmantota kaudzes atmiņa.
Tas kļūst iespējams pārrakstot atmiņas gabalu struktūru.
Ja atmiņa bija atbrīvota, tad atmiņas gabali var tikt uzglabāti vienā no bin saistītiem sarakstiem.
Eksistē divi bin saraksta veidi: ātrais (fastbin) un parastais (normal bin).


Ātrais saraksts ir paredzēts bieži izmantotu, mazu atmiņas gabalu glabāšanai.
Pēc noklusējuma ātro atmiņas gabalu izmērs nepārsniedz 64 baitus (sk. 1.13. attēlu), bet to var palielināt līdz 80 baitiem \cite {MALLOC}. 
Tas varētu būt nepieciešams, ja programma ir bieži izmantotas struktūras, kuru izmērs pārsniedz 64 baitus.
Atmiņas gabali atrodas viensaišu sarakstā un nav sakārtoti, jo katrā bin sarakstā atrodas elementi, kuriem ir vienāds izmērs.
Lai samazinātu fragmentēšanas iespējamību, programma, kad pieprasa vai atbrīvo lielus atmiņas gabalus var sapludināt atmiņas gabalus, kuri atrodas fastbin sarakstā.
Piekļuve tādiem atmiņas gabaliem ir ātrāka nekā piekļuve parastiem gabaliem. 
Fastbin saraksta elementi ir apstrādāti pēdējais iekšā pirmais āra (jeb LIFO) kārtībā \cite {Binning}.
Kad tiek pieprasīta atmiņa no fastbin saraksta, tad jebkurš atmiņas gabals tiek atgriezts konstantā laikā  \cite {ACCA}.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.35]{fastbins}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Ātrais saraksts}}}
\label{fig:fastbin}
\end{figure}

Kopumā ir 128 parastie saraksti, kurus var sadalīt 3 veidos. 
Pirmkārt, bin saraksts, kurš uzglabā nesakārtotus gabalus, kuri nesen bija atbrīvoti.  
Pēc tam tie tiks novietoti vienā no atlikušiem bin sarakstiem: mazā vai lielā izmēra. 
Mazā izmēra saraksts uzglabā atmiņas gabalus, kuri ir mazāki par 512 baitiem. 
Vairāki ātrie gabali var būt sapludināti un uzglabāti dotajā sarakstā. 
Mazā izmērā saraksti iekļauj gabalus ar vienādu izmēru. 
Lielā izmēra saraksts uzglabā atmiņas gabalus, kuri ir lielāki par 512 baitiem, bet mazāki par 128 kilobaitiem. 
Lielā izmēra saraksta elementi ir sakārtoti pēc izmēra un ir iedalīti pirmais iekšā, pirmais ārā (jeb FIFO) kārtībā \cite {Binning}. 
Tāda veidā vienmēr tiek atgriezts gabals, kurš ir vislabāk piemērots.
Tas ir, kad gabalam ir mazāks izmērs no pārējiem saraksta gabaliem, kurš apmierina pieprasījumu pēc atmiņas.
Gabali, kuru izmērs ir lielāks par 128 kilobaitiem netiek uzglabāti bin sarakstos, jo tiek iedalīti, izmantojot mmap(). 




\subsubsection{Atmiņas gabali}
\label{subsec:atminas_gabali}

Kaudze sastāv no daudziem atmiņas gabaliem.
Eksistē divu veidu atmiņas gabali: parastie (normal chunk) un ātrie (fast chunk) gabali. 
Ātrie gabali ir mazā izmērā (parasti līdz 64 baitiem) un pieder ātrajām sarakstām, bet parastie gabali - parastajām sarakstam. 
Ātrie un parastie gabali, tiek izmantoti, lai nodrošinātu atmiņas iedalīšanu no kaudzes.
Atmiņas gabala fiziska struktūra ir vienāda abu veidu gabaliem, bet ir atkarīga no stāvokļa un var tikt interpretēta dažādi.
Atmiņa no kaudzēs tiek iedalīta, izmantojot malloc\_chunk struktūru (sk. 1.14. attēlu). 
Sīkāk struktūras malloc\_chunk elementi ir aprakstīti tabulā 1.1.

\begin{table}[H]
\caption{\textbf{\fontsize{11}{12}\selectfont {\\ Atmiņās gabalu struktūras elementu apraksts}}} 
\label{table:kysymys}
\centering
	\begin{tabular}{|l|l|r|p{5cm}|}
	  \hline
	Elements & Nozīme \\
	\hline
	  INTERNAL\_SIZE\_T               prev\_size & Iepriekšēja gabala izmērs (baitos), ja tas bija atbrīvots\\
      \hline
      INTERNAL\_SIZE\_T               size & Kārtējā gabala izmērs (baitos) \\
      \hline
      struct malloc\_chunk*          fd & Rādītājs uz nākamo atbrīvoto gabalu, ja kārtējais  \\
                                                     & gabals ir atbrīvots un pievienots dubultsaišu bin \\
                                                     & sarakstām\\
      \hline
      struct malloc\_chunk*          bk & Rādītājs uz iepriekšējo atbrīvoto gabalu, ja kārtējais  \\
                                                     & gabals ir atbrīvots un pievienots dubultsaišu bin \\
                                                     & sarakstām\\
    \hline
	\end{tabular}
\end{table}
\begin{figure}[h]
\begin{lstlisting}[language=C++]
struct malloc_chunk  {
                INTERNAL_SIZE_T               prev_size;
                INTERNAL_SIZE_T               size;
                struct malloc_chunk*          fd;
                struct malloc_chunk*          bk;
 }
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas gabala struktūra}}}
\end{figure}

Katru reizi ir iedalīts lielāks atmiņas gabals nekā pieprasīts ar malloc() funkciju.
Tas ir nepieciešams, lai varētu saglabāt uzturēšanai nepieciešamo informāciju. 
Iedalītam gabalam uzturēšanas informācija ir divas INTERNAL\_SIZE\_T tipa vērtības, kas vienādas ar 4*2 vai 8*2 baitiem. 
Tas ir atkarīgs no tā, kāda vērtība ir piešķirta INTERNAL\_SIZE\_T makrodefinīcijai, 4 vai 8 baiti.
Ar INTERNAL\_SIZE\_T var uzdot iekšējo vārda izmēru (word-size), kurš pēc noklusējuma ir vienāds ar size\_t izmēru.
Datoriem ar 64 bitu tehnoloģiju, 4 baitu vērtības piešķiršana makrodefinīcijai  var samazināt aizņemtās atmiņas daudzumu, bet ierobežo lielāko iespējamo gabala izmēru.
Tā kā 4 baitos nevar saglabāt skaitli, kas ir vienāds vai lielāks par \(2^{32}\), tad laukā \texttt{prev\_size} un \texttt{size} vērtībai ir jābūt mazākai par šo ierobežojošo vērtību.
Kad gabals ir iedalīts, tad uzturēšanas informācijai ir izmantoti divas INTERNAL\_SIZE\_T tipa vērtības un, kad gabals ir atbrīvots, tad  dubultsaišu saraksta uzturēšanai, papildus tiek izmantoti divi rādītāji (fd un bk) uz iepriekšējo un nākamo \texttt{malloc\_chunk} struktūras objektiem. 
Kopējais atmiņas gabala uzturēšanai izmantotais datu izmērs var būt 16 baiti (ja INTERNAL\_SIZE\_T un rādītāja izmērs ir 4 baiti), 24 baiti (ja INTERNAL\_SIZE\_T ir 4/8 baiti un rādītāja izmērs ir 8/4 baiti) vai 32 baiti (ja INTERNAL\_SIZE\_T un rādītāja izmērs ir 8 baiti).  
Otrs iemesls kāpēc ir iedalīts lielāks atmiņas daudzums ir izlīdzināšana skaitlim, kas ir  2*sizeof(INTERNAL\_SIZE\_T) reizinājums. Šīs skaitlis ir vienāds ar 8 baitu izlīdzinājumu, ja  makrodefinīcijas INTERNAL\_SIZE\_T vērtība  ir vienāda ar 4 baitiem \cite {MALLOC}.  

 \begin{figure}[h]
\begin{center}
%\includegraphics[scale=0.22]{chunks}
\begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[scale=0.22]{used_chunk}
        \caption{Iedalīts atmiņas gabals}
    \end{subfigure}%
\begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[scale=0.22]{free_chunk}
        \caption{Atbrīvots atmiņas gabals}
    \end{subfigure}%
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas gabalu grafiskais struktūras attēlojums}}}
\label{fig:chunks}
\end{figure}


No kreisās pusēs  attēlots (sk. 1.15. attēlu) \cite{CHOFM} atmiņas gabals, kurš bija iedalīts procesam, no labās, tās, kurš bija atbrīvots.
Abos gadījumos rādītājs chunk attēlo atmiņas gabalu sākumu. Pēc šī radītāja var iegūt iepriekšēja gabala izmēru, ja iepriekšējais gabals bija atbrīvots.
Gadījumā, kad iepriekšējais gabals ir iedalīts, tad chunk uzglabā daļu no lietotāja datiem, kas dublēti no iepriekšējā gabala. 
Pēc tam seko kārtēja gabala izmērs un 3 biti ar meta informāciju. 



Tā kā notiek izlīdzināšana 2*sizeof(INTERNAL\_SIZE\_T), kas ir vienāda 8 - ka vai 16 - ka  reizinājumam, tad 3 pēdējie biti netiek izmantoti izmēra glabāšanai. 
Šos bitus izmanto kontroles zīmēm. Katram bitam ir sava nozīme, kura aprakstīta 1.2. tabulā.

  \begin{table}[H]
\caption{\textbf{\fontsize{11}{12}\selectfont {\\ Atmiņas gabala kontroles zīmes}}} 
\label{table:kysymys}
\centering
	\begin{tabular}{|c|l|r|p{5cm}|}
	  \hline
	Kontroles zīme & Nozīme \\
	\hline
	  A & gabals nepieder galvenajai arēnai \\
      \hline
      M & gabals tiek iedalīts ar mmap() sistēmas izsaukumu \\
      \hline
      P & iepriekšējais atmiņas gabals tiek izmantots  \\
    \hline
	\end{tabular}
\end{table}

Rādītājs mem ir malloc() funkcijas atgriežamā vērtība, jeb radītājs uz iedalīto atmiņas apgabalu. Iedalīts apgabals stiepjas līdz atmiņas gabala struktūras beigām.
Pēc šī rādītāja var tikt uzglabāti dati, kad atmiņa ir iedalīta un, ja tā ir atbrīvota, tad šeit tiks uzglabāti divi radītāji uz nākamo un iepriekšējo atbrīvotiem gabaliem, kas atrodas saistītajā sarakstā. 


Eksistē divi citi atmiņas gabali (top chunk un last\_remainder), kuriem ir īpaša nozīme. 
Top chunk ir atmiņas gabals, kuram ir kopīga robeža ar procesa kaudzes segmentu.
Top gabals ir izmantots gadījumos, kad nav piemērotu gabalu bin sarakstos, kuri apmierina pieprasījumu vai varētu būt saplūdināti, lai apmierinātu pieprasījumu pēc atmiņas.
Sākotnēji atmiņās iedalīšana sākas ar top gabalu, bet top gabals nodrošina arī pēdējo iespēju iedalīt pieprasīto atmiņas daudzumu.
Top gabals var mainīt savu izmēru. Tas saraujas, kad atmiņa ir iedalīta un izstiepjas, kad atmiņa ir atbrīvota blakus top gabala objektam. 
Ja ir pieprasīta atmiņa, kas ir lielāka par pieejamo, tad top gabals var paplašināties ar brk() izsaukuma palīdzību.
Top gabals ir līdzīgs jebkuram citam atmiņas apgabalam. 
Galvenā atšķirība ir lietotāja datu sekcija, kura netiek izmantota, P kontroles zīme, kura vienmēr norāda, ka iepriekšējais gabals ir izmantots, ka arī speciāla top gabala apstrāde, lai nodrošinātu, ka top gabals vienmēr eksistē \cite {BLACKHAT}.

Last\_remainder ir vel viens atmiņas gabals ar īpašu nozīmi.
Tas ir izmantots gadījumos, kad ir pieprasīts mazs atmiņas gabals, kas neatbilst nevienam bin saraksta elementam. 
Last\_remainder ir dalījuma atlikums, kurš izveidojās pēc lielāka gabala sadalīšanas, lai apmierinātu pieprasījumu pēc maza gabala  \cite {BLACKHAT}.


%\section{Atmiņas statistika}

%Linux nodrošina malloc\_stats() funkciju, kura izdrukā atmiņas statistiku standartā kļūdu plūsmā stderr. 
%Katrai atmiņas arēnai  funkcija izdruka kopējo iedalītās atmiņas daudzumu \texttt{(system bytes)} un pašreiz izmantoto atmiņas daudzumu \texttt{(in use bytes)}.
%Ir pieejama kopēja statistikā visām arēnām pēc abiem iepriekš minētiem parametriem, ka arī tiek izdrukāts maksimālais bloku un baitu daudzums, kurš bija iedalīts ar mmap() sistēmas izsaukumu. 

\section{Secinājumi}
\begin{enumerate}
\item Ir apskatītas atmiņas izmetes ģenerēšanas iespējas, nosacījumi un atkļūdošanas process;
\item Tiek aplūkota literatūra un GNU C bibliotēkas malloc pirmkods;
\item Ir apkopotas zināšanas un uzzīmēta ptmalloc2 iedalītāja organizācijas reprezentācija  (sk. 1.12. attēlu);
\item Galvenie secinājumi par kaudzi:
    \begin{itemize} \itemsep5pt \parskip5pt \parsep5pt
    \item kontrolētā atmiņas iedalīšana ir dinamiskā atmiņas iedalīšana, kura notiek programmas izpildes laikā, un atmiņa parasti tiek iedalīta no kaudzes;
    \item kaudzes segments ir procesa adrešu telpas apgabals, kurš var tikt paplašināts;
    \item iedalīt atmiņu no kaudzes var no lietotnes ar malloc() vai new palīdzību;
    \item kaudze sastāv no daudziem iedalītiem un atbrīvotiem atmiņas gabaliem.
    Atbrīvotie gabali var būt savienoti sarakstā, pārrakstot lietotāja datus;
    \item vienu arēnu var veidot vairākas kaudzes, kas ir savienotās savā starpā.
    \end{itemize}
    
\end{enumerate}