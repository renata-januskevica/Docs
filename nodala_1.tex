%Šajā nodaļā tiek aplūkots atmiņas izmetes jēdziens, ka arī aprakstītas atmiņas izmetes ģenerēšanas iespējas un nosacījumi.
%Nodaļā ir aprakstīts atkļūdošanas process, kas var būt paveikts, izmantojot atmiņas izmeti.
%Uz šiem pamatjēdzieniem, turpmāk tiks balstīta izstrādājamā kaudzes atkļūdošanas metode.

\section{Kaudzes problēmu apraksts}
 \label{sec:problems}
Par kaudzes problēmām bakalaura darbā tiek uzskatītas problēmas, kuras rodas lietotnē nepareizās kaudzes pārvaldības dēļ: 
\begin{itemize}
\item nekorekta kaudzes pārvaldība ar malloc() vai citām līdzīgām funkcijām;
\item nekorekta kaudzes pārvaldība, ko nodrošina iedalītājs.
\end{itemize}
Darbā tiek izpētītās 3 kaudzes problēmas: atmiņas noplūde, fragmentēšana, maksimālās atmiņas izmantošanas problēma.
Šī sadaļa satur problēmu aprakstus, kuri palīdzēs turpmāk izvirzīt hipotēzes par problēmu pazīmēm atmiņas izmetē un sagatavot atmiņas izmešu paraugus dotajām problēmām.
\subsection{Atmiņas noplūde}

Atmiņas noplūde (memory leak) ir viena no bieži sastopamām problēmām C un C++ valodās \cite{atparv}.
Atmiņas noplūde notiek nepareizās lietotāja atmiņas pārvaldības dēļ, kad atmiņa, kura vairs netiks izmantota programmā, netiek atbrīvota.

Atmiņas noplūdes problēmu var sadalīt divos dažādos veidos: fiziskā un loģiskā atmiņas noplūde \cite{JMMR}.
Fiziskā atmiņas noplūde ir novērojama, kad atmiņas adreses, kuras tika iedalītas procesam,  kļūst nepieejamas, pazaudētas, tas notiek, kad procesa adrešu telpā uz iedalīto atmiņas gabalu kaudzē nenorāda neviens rādītājs.
Šīs programmas stāvoklis var būt novērojams 3 iemeslu dēļ \cite{JMMR}:
\begin{itemize}
\item pēdēja norāde uz atmiņas gabalu ir pārrakstīta vai norāde bija palielināta, piemēram, lai sasniegtu datus ar nobīdi;
\item norāde atrodas ārpus darbības lauka (out of scope);
\item atmiņas bloks, kurš glabāja norādi, bija atbrīvots.
\end{itemize}

Loģiskā atmiņas noplūde ir novērojama, kad iekšējā buferī, rindā vai citā datu struktūrā ir uzglabātas norādes uz dinamiski iedalītu atmiņu, bet norāžu skaits pieaug neierobežoti.
Loģiskā atmiņas noplūdi bieži nosauc par slēpto atmiņas noplūdi (hidden memory leak) \cite{RRUU}, jo atmiņa ir joprojām sasniedzama no programmas, bet nekad netiek atbrīvota.

Abos gadījumos sekas ir vienādas.
Sākumā tiks novērota pakāpeniskā procesa palēnināšana, jo daļa no informācijas tiks uzglabāta lapošanas failā (paging file).
Kaut kāda brīdī, kad tiks iztērēta visā dinamiskā atmiņa, katrs malloc() funkcijas izsaukums būs neveiksmīgs.
Šeit var notikt kritiskā kļūda, kuras cēlonis ir sliktā programmēšanas prakse.
Programmētāji ne vienmēr pārbauda malloc() rezultātu pirms vērsties pēc malloc() funkcijas atgrieztās norādes.  
Mēģinājums piekļūt null adresei  izraisīs Segmentation fault kļūdu.
Ja programmā bija paredzēts, ka malloc() var atgriezt null, tad process turpinas izpildi ierobežotā režīmā, jo vairs nav iespējams dinamiski iedalīt atmiņu un izpildīt daudzus uzdevumus. 
Daudzās sistēmās tas nav pieļaujams un var tikt uzstādīti dažādi ierobežojumi, kuri pēc ierobežojošās vērtības sasniegšanas (izpildes laiks, patērētās atmiņas) automātiski pārtrauks procesa darbību. 

\begin{figure}[h]
\begin{lstlisting}
#include <string>
using namespace std;

int main() {
    string *str;

    for (int i=0; i<10001; i++) {
        // 10000*14 bytes are lost
        str = new string("Hello, World!");
    }
    delete str;

    return 0;
}
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas noplūde, C++}}}
\end{figure}

Atmiņās noplūdes problēma ir uzskatāmi nodemonstrēta piemērā (sk. 2.1. attēlu).
Programma  iedala 10001 atmiņas gabalus ar new operatora palīdzību. 
Rādītājs \texttt{str} katru reizi tiek pārrakstīts un norāda uz kārtējo iedalīto atmiņas gabalu, kurā izmērs ir 14 baiti.
Tā kā atmiņas adreses kļūst pazaudētas un nav iespējas piekļūt iepriekšējiem elementiem pēc tam kad  \texttt{str} radītājs ir parakstīts, tad piemēra ir redzama fiziskā atmiņas noplūde.
Beigās tiek atbrīvots tikai viens atmiņas gabals, kurš bija iedalīts pēdējais. 
Programmas darbības laikā kļūst pazaudēti 10000 gabali, kuru kopējais izmērs ir 140000 baiti.
 Pēc programmas izpildes beigām visā procesam iedalītā atmiņa tiek atgriezta operētājsistēmai.


Sekojošos gadījumos sistēmas kļūst viegli ievainojamas, ja tajās ir kļūda, kas izraisa atmiņās noplūdi \cite{RTTV}: 
\begin{itemize}
\item { kad operētājsistēma neatbrīvo, lietotnes izpildei izmantoto atmiņu pēc tam, kad lietotne beidz savu darbību, piemēram, AmigaOS;}
\item { ja servera vai citās programmas darbojās visu laiku bez apstāšanās; }
\item { ja portatīvām ierīcēm ir ierobežots atmiņas daudzums;}
\item { ja programmas pieprasa atmiņu uzdevumiem, kuri izpildās ilgstošu laika periodu; }
\item { reālā laikā sistēmās, jo ir svarīgi iegūt rezultātu ierobežotajā laikā. }
\end{itemize}

Atmiņas noplūdes problēmu ir grūti atkļūdot,  jo nav zināmi nosacījumi, kuriem izpildoties notiek atmiņas noplūde. 
Ja ir redzamas sekas (ir atmiņas izmete un programma pabeidza savu darbību), bet nav zināms problēmas cēlonis, tad izstrādātājiem ir nepieciešams daudz resursu, lai atkārtotu un izlabotu atmiņas noplūdi. 
Eksistē vairāki rīki, kuri palīdz atkļūdot atmiņas noplūdes problēmu, tādi ka: Valgrind, Totalview, Purify. 
Taču tie ne vienmēr sniedz pietiekamu informāciju un bieži netiek izmantoti strādājošās sistēmās, jo piedāvātas atkļūdošanas tehnikas un rīki var palēnināt sistēmas darbību.
Piemēram, ieslēdzot  memcheck rīku iekš Valgrind instrumentācijas ietvara, programmas izpildes ātrums palēninās aptuveni 20-30 reizes \cite{UVD}.

Reālajās sistēmās problēma var izpausties uzreiz pēc palaišanas, bet var kļūt novērojama tikai pēc dažiem gadiem. 
Abi gadījumi ir izplatīti \cite{HTTM}.
Tā kā atmiņas noplūdes rezultātā atmiņa tiek pazaudēta, tad var periodiski novērot procesa atmiņas patēriņa pieaugumu.
Pazīme, kas varētu liecināt par atmiņas noplūdi ir pārmērīgs\footnote{Šajā kontekstā pārmērīgs nozīme, ka izmērs ir lielāks par to, kuru paredz programmētājs un tas rāda pamatotas šaubas, par atmiņas noplūdes problēmas esamību programmā.}
atmiņas daudzums, kas visu laiku pieaug. 
Kad process izmanto pārmērīgo atmiņu un izmantotās atmiņas daudzums nemainās, tad šī pazīme var dot tikai aptuvenu novērtējumu par dotās problēmas esamību, jo eksistē vairākas citas problēmas, piemēram, fragmentēšana, maksimālās atmiņas izmantošanas problēma vai kļūdas trešās puses bibliotēkās, kuras var palielināt izmantotās atmiņas daudzumu.


%==============================================


\subsection{Maksimālās atmiņas izmantošanas problēma}
 \label{sec:peak_mem}
 Maksimālās atmiņas izmantošanas (peak memory utilization) problēma var notikt, kad iedalītu un atbrīvotu gabalu izmēru summa kaudzē sasniedz maksimumu procesa izpildes laikā.
Ir svarīgi pievērst uzmanību gadījumiem, kad var tikt sasniegts maksimums.
Piemēram, tas var notikt, kad process tiecās pie trapa virsotnes vai maksimuma punkta.

Atmiņas daudzums, kas tiek izmantots programmas izpildes laikā var visu laiku mainīties.
Pētījumā \cite{PWMS} tiek apkopoti trīs svarīgākas atmiņas izmantošanas shēmas: traps (ramps),  maksimums (peaks),  plato (plateaus).
Citas atmiņas izmantošanas shēmas ir iespējamas, bet izpaužas ļoti reti.
Ne visām programmām ir raksturīgas visās trīs shēmas, bet vairākumam ir raksturīga viena vai divas no tām.
Šīs shēmas tika apkopotas, balstoties uz kvantitatīvo programmu novērtējumu \cite{PWMS}. 
\begin{itemize}
\item Traps. Programma uzkrāj datu struktūras monotoni. 
Tas varētu notikt, tāpēc ka uzdevuma atrisināšanai ir nepieciešams paveikt daudzas darbības un pakāpeniski uzbūvēt daudzas  datu struktūras. 
Lai atrisinātu uzdevumu, atmiņas patēriņš monotoni aug. Pēc uzdevuma atrisināšanas atmiņas patēriņš strauji samazinās;
\item Maksimums. Šo veidu var nosaukt par trapu tikai ļoti īsa laika periodā.
Daudzām programmām var būt nepieciešams izveidot lielas datu struktūras, kāda uzdevuma izpildīšanai.
Pēc šī uzdevuma pabeigšanas gandrīz visā pieprasītā atmiņa var tikt atbrīvota.
Grafiks šai shēmai izskatās kā lauztā līnija un atmiņas patēriņš var svārstīties dramatiski;
\item Plato. Novērojama, kad programmas ātri uzbūve datu struktūras un izmanto tās ilgā laika periodā, bieži izmanto līdz programmas izpildes beigām.
\end{itemize}


Problēma ir novērojama, kad liels atmiņas daudzums netiek atgriezts operētājsistēmai pēc izmantošanas, pat tad, ja gandrīz visa atmiņa tiek atbrīvota ar free() vai delete palīdzību.
Rezultātā process var patērēt pārmērīgo atmiņas daudzumu, kurš nebija paredzēts projektējumā.
Šī situācija kļūst iespējama, ja notiek daudzi pieprasījumi pēc atmiņas, kas ir mazāki par 128 kilobaitiem.
Pieprasījumi pēc lielākiem atmiņas gabaliem tiks apstrādāti ar mmap() sistēmas izsaukumu un neizraisīs doto problēmu.
Pēc mmap() izsaukumiem atmiņu ir iespējams atgriezt operētājsistēmai ar munmap() palīdzību, jo atmiņa neatrodas kaudzē. 
Izmantojot brk() sistēmas izsaukumu, kamēr netiks atbrīvots atmiņas gabals, kas atrodas beigās, atmiņa netiks atgriezta operētājsistēmai.

Pazīme, kas varētu liecināt par problēmas esamību ir pārmērīgs atmiņas patēriņš pēc trapa virsotnes vai maksimālā punkta sasniegšanas.
%==============================================

\subsection{Fragmentēšana}

"Ir pierādīts, ka katram atmiņas iedalīšanas algoritmam, vienmēr ir iespējama situācija, ka kāda lietotne pieprasīs 
un atbrīvos atmiņu tāda veidā, ka tās nojauks iedalītāja stratēģiju un izraisīs lielu fragmentēšanu. 
Ir pierādīts ne tikai tas, ka nav laba iedalīšanas algoritma, bet arī tas, ka katrs iedalīšanas algoritms var būt slikts dažām lietotnēm" \cite{PWMS}.
Tātad, fragmentēšanas problēma var būt aktuālā daudzām C un C++ lietotnēm, kuras pieprasa atmiņu no kaudzes.

Fragmentēšanas problēmu var iedalīt divos dažādos veidos: iekšējā un ārējā fragmentēšana.
Iekšējā fragmentēšana notiek, kad tiek iedalīts lielāks atmiņas gabals nekā tika pieprasīts.
Izlīdzināšana ir viens no iekšējās fragmentēšanas cēloņiem.
Iekšējo fragmentēšanu ir iespējams paredzēt, jo var izskaitļot kuram skaitlim tiks noapaļots izmērs.
GNU C bibliotēkā notiek atmiņas gabalu izlidināšana 8 - ka vai 16 - reizinājumam.
Izlīdzināšana samazina atšķirīgu gabalu izmēru skaitu kaudzē.
Nodrošinot izlīdzināšanu, ir palielināta iekšējā, turklāt ir samazināta ārējā fragmentēšana \cite{RAN}.
Ārējā fragmentēšana ir nespēja iedalīt atmiņas gabalu kaudzē, kad kaudzē pietiekoši daudz brīvas atmiņas, lai apmierinātu doto pieprasījumu.
Ārējā fragmentēšana var izpausties ar laiku, kad daudzas reizes jau tika iedalīti un atbrīvoti dažāda izmēra atmiņas gabali.
Fragmentēšanas rezultātā pārmērīgi tiek izlietoti kaudzes resursi, jo kad pieprasījums pēc atmiņas nevar tikt apmierināts, tad notiek kaudzes piespiedu paplašināšana.

Fragmentēšanu mēra procentos (\%). 
Stradajošā sistēmā var būt vairāki veidi kā var mērīt atmiņas fragmentēšanu \cite{MSJ}. 
Atmiņas izmetē ir iespējams izrēķināt ārējo fragmentēšanu tikai uz procesa partraukšanas brīdī.
Tātad ir iespējams izrēkināt tikai momentāno kaudzes fragmentēšanu.
Fragmentēšana var būt izrēķināta kā attiecība starp atmiņas daudzumu kaudzē, ko aizņem iedalītājs pret atmiņas daudzumu, ko izmanto process (neietilpst atbrīvotie atmiņās gabali).

Turpmāk ir apskatīts piemērs, kurš demonstrē iekšējās fragmentēšanas cēloņi.
Šīs C valodā uzrakstītais kods izdruka atmiņas gabala izmēru, kurš īstenībā tiek iedalīts no kaudzes (sk. 2.2. attēlu).
Piemēra ir redzams, ka tiek iedalīti 4 baiti, bet programma izdruka beigu rezultātu - 16 baiti.
Dotajā piemērā iekšējā fragmentēšana ir vienāda ar 12 baitiem.

Algoritms ir sekojošs: 
\begin{enumerate}
\item ar malloc() tiek iedalīts atmiņas apgabals;
\item  tiek iegūta size elementa vērtība (objektam ar malloc\_chunk struktūru);
\item  tiek atņemtas A, M, P kontroles zīmes 111 = 7 un iegūts iedalītā atmiņas  gabala izmērs;
\item  tiek atbrīvota atmiņa.
\end{enumerate}

\begin{figure}[h]
\begin{lstlisting}
 #include <stdio.h>
 #include <malloc.h>

 int main () {
     char * ptrl;
     int chunk_size;

     ptrl = (char *)malloc(4);
 
     /* get value of chunk size (the second malloc_chunk element) */
     chunk_size = *((char *) ptrl - sizeof(size_t));
     /* the lower 3-bits are used as metadata */
     chunk_size = chunk_size - (chunk_size & 7);
 
     printf("size = %d\n", chunk_size);
     free(ptrl);
 
     return 0;
 }
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Izmēra noteikšana iedalītām gabalam}}}
\end{figure}


%==============================================


\section{Atmiņas izmete}

Pēc tam, kad ir identificētas problēmas, ir nepieciešams sagatavot atmiņas izmešu paraugus dotajām problēmām.
Pirms uzģenerēt atmiņas izmetes paraugus, ir nepieciešams:
\begin{itemize}
    \item   atrast piemērotāko veidu atmiņas izmešu ģenerēšanai;
    \item   nokonfigurēt iestatījumus Linux operētājsistēmā, lai varētu uzģenerēt atmiņas izmeti.
\end{itemize} 

 \subsection{Atmiņas izmetes ģenerēšana}
Sistēmās, kuras atbalsta POSIX standartus, ir signāli \cite{USP}, kuri, pēc noklusētās apstrādes, izraisa atmiņas izmetes ģenerēšanu un pārtrauc procesa darbību. 
Šos signālus var atrast  \texttt{man 7 signal} komandas izvadā. 
Signāliem, kuri izraisa izmetes ģenerēšanu, signālu tabulā \cite{signal} ir lauks ar vērtību core, kas atrodas ailē ar nosaukumu darbība (Action). 
%Uzģenerētā atmiņas izmete iekļauj sevī procesa atmiņas attēlojumu uz procesa pārtraukšanas brīdi, piemēram, CPU reģistrus un steka vērtības katram pavedienam, globālos un statiskos mainīgos. 
%Atmiņas izmeti var ielādēt atkļūdotājā, tāda kā gdb, lai  apskatītu programmas stāvokli uz brīdi, kad atnāca operētājsistēmas signāls \cite{core}.
%Veicot atmiņas izmetes analīzi, kļūst iespējams atrast un izlabot kļūdas, pat tad, ja nav tiešas piekļuves sistēmai. 


Reālajās sistēmās atmiņas izmetes tiek uzģenerētas atmiņas kļūdu dēļ. 
Dažas no kļūdām sīkāk ir aprakstītas \ref{sec:problems} sadaļā. 
Bet eksistē vairākas iespējas kā atmiņas izmeti var uzģenerēt patstāvīgi.
Tas varētu būt nepieciešams programmas atkļūdošanai.
Atmiņās izmeti var uzģenerēt no programmas koda,  gdb atkļūdotāja vai komandrindas interpretatora.
Turpmāk katra no iespējam tiks apskatīta sīkāk, lai atrastu piemērotāku veidu kā var uzģenerēt atmiņas izmeti, dotā darba veiktajām pētījumam.

\subsubsection{Atmiņas izmetes ģenerēšana no koda}

Ģenerējot atmiņas izmeti no programmas koda, ir divas iespējas: process var turpināties vai beigt savu darbību pēc signāla nosūtīšanas.

\begin{figure}[h]
\begin{lstlisting}
#include <signal.h>

int main ()  {

    raise(SIGSEGV); /* Signal for Invalid memory reference */
	
    return 0;
}
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes ģenerēšana, pārtraucot procesa darbību}}}
\end{figure}

Ja nav nepieciešams, lai process turpinātu darbību, tad var izmantot funkcijas raise(), abort(), kā arī var apzināti pieļaut kļūdu kodā.
Tāda kļūda kā dalīšana ar nulli nosūta SIGFPE signālu, bet vēršanās pēc null radītāja - SIGSEGV signālu.
Izmantojot funkciju raise(), ir iespējams norādīt atmiņas izmeti izraisošo signālu.
Piemērā (sk. 2.3. attēlu) ir redzams C kods, kur funkcija raise() nosūta SIGSEGV signālu izpildāmai programmai. 
Pēc šī izsaukuma izpildes tiek izvadīts ziņojums: Segmentation fault (core dumped).
Atmiņas izmeti lietotāju procesiem var atrast darba mapē, jo Linux operētājsistēmā tā ir noklusēta atmiņas izmetes atrašanas vieta, bet noklusētais atmiņas izmetes nosaukums ir core.
\begin{figure}[h]
\begin{lstlisting}
 #include <stdlib.h>

 int main () {
     int child = fork();
     if (child == 0) {
         abort(); /* Child */
     }
     return 0;
 }
 \end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes ģenerēšana, turpinot procesa darbību}}}
\end{figure}

Ir iespējams uzģenerēt atmiņas izmeti, nepārtraucot procesa darbību (sk. 2.4. attēlu). 
To var panākt ar fork() funkcijas palīdzību. Funkcija fork() izveido bērna procesu, kas ir vecāka procesa kopija.
Funkcija fork(), veiksmīgas izpildes gadījumā, bērnu procesam atgriež 0 vērtību. 
Pēc abort() funkcijas izpildes, bērns beidz izpildi un uzģenerē atmiņas izmeti. Vecāks process turpina izpildi.




\subsubsection{Atmiņas izmetes ģenerēšana no gdb}

Atmiņas izmetes ģenerēšanas nolūkam var izmantot gdb komandas: \texttt{generate-core-file [file]}(sk. 2.5. attēlu) vai \texttt{gcore [file]}. Šīs komandas izveido gdb pakļautā procesa atmiņas izmeti. 
Izmantojot gdb, var uzģenerēt atmiņas izmeti, kura atbilst kādam pārtraukuma punkta stāvoklim. 
Neobligāts arguments \texttt{filename} nosaka atmiņas izmetes nosaukumu. Šī gdb komanda ir realizēta GNU/Linux, FreeBSD, Solaris un S390 sistēmās \cite {gdb_gen_core}.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) attach <pid>
(gdb) generate-core-file <filename>
(gdb) detach
(gdb) quit
 \end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes ģenerēšana, izmantojot gdb}}}
\end{figure}


\subsubsection{Atmiņas izmetes ģenerēšana no komandrindas interpretatora}
Trešā iespēja ir nosūtīt signālu, izmantojot komandrindas interpretatoru. 
Komanda kill var nosūtīt jebkuru signālu procesam.
Pēc komandas  \texttt{kill -<SIGNAL\_NUMBER> <PID>}, signāls ar numuru  SIGNAL\_NUMBER tiks nosūtīts procesam ar norādītu PID vērtību.
Izmantojot shell komandrindas interpretatoru ir  iespējams izmantot īsinājumtaustiņus signālu nosūtīšanai. 
Nospiežot Control + $\backslash$ tiks nosūtīts SIGQUIT signāls procesam, kas pašreiz ir palaists (sk. 2.6. attēlu) \cite {nosacijumi}. 
Šajā piemēra ziņojumu - Quit (core dumped), izdruka shell. 
Šīs komandrindas interpretators noteic, ka  sleep procesu (shell bērnu) pārtrauca SIGQUIT signāls. 
Pēc šī signāla nosūtīšanās, darba mapē tiek uzģenerēta atmiņas izmete. 

\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
$ ulimit –c unlimited
$ sleep 30
Type Control + \
^\Quit (core dumped)
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes ģenerēšana, izmantojot īsinājumtaustiņus}}}
\end{figure}
 Ir apskatītas vairākas iespējas kā var uzģenerēt atmiņas izmeti (no programmas koda,  gdb atkļūdotāja vai komandrindas interpretatora).
 Pētījumam vislabāk ir piemērots tāds veids, kuru izmantojot būtu iespējams zināt programmas stāvokli uz ģenerēšanas brīdi.
 Vislabāk šīm nolūkam ir piemērots atmiņas izmetes ģenerēšanas veids no programmas koda, jo nevajag speciāli uzstādīt pārtraukuma punktus, ka arī nevajag izmantot bezgalīgus ciklus, lai  pārtrauktu tos no komandrindas interpretatora.
 Pētījumam nav svarīgi, lai process turpinātu darbību, tāpēc tiks izmantots abort() funkcijas izsaukums no programmas koda.
 
 
\subsection{Atmiņas izmetes ģenerēšanas nosacījumi}
Lai  uzģenerētu atmiņas izmeti ir jābūt izpildītiem sekojošiem nosacījumiem \cite {nosacijumi}:
%\vspace{-6pt}
\begin{itemize}
	\item   ir jānodrošina atļauja procesam rakstīt atmiņas izmeti darba mapē;
	\item 	ja datne, ar vienādu nosaukumu jau eksistē, tad uz to ir jābūt ne vairāk kā vienai stingrai saitei;
	\item 	izvēlētai darba mapei ir jābūt reālai un jāatrodas norādītajā vietā;
	\item 	Linux core datnes izmēra robežai {RLIMIT\_CORE} jāpārsniedz ģenerējamā faila izmēru, { RLIMIT\_FSIZE} robežai jāļauj procesam izveidot atmiņas izmeti;
	\item 	ir  jāatļauj lasīt bināro datni, kura ir palaista;
	\item 	failu sistēmai, kurā atrodas darba mape, ir jābūt uzmontētai priekš rakstīšanas, tai nav jābūt pilnai un ir jāsatur brīvie indeksa deskriptori;
	\item 	bināro datni jāizpilda lietotājam, kurš ir datnes īpašnieks (group owner).
\end{itemize} 
 
 Pēc noklusējuma atmiņas izmetes ģenerēšanas iespēja ir izslēgta,  \texttt{ulimit -c unlimited} komanda ļauj ieslēgt atmiņas izmetes ģenerēšanu.
 Pēc atmiņas izmēra uzstatīšanas, izmantojot komandu,  tika uzģenerētās 3 atmiņas izmetes, izmantojot programmas (sk. 1. pielikumu), (sk. 2. pielikumu), (sk. 3. pielikumu).

 


 
 
\section{Atkļūdošana, izmantojot atmiņas izmeti}
Pirms izvirzīt hipotēzes par problēmu pazīmēm atmiņas izmetē ir nepieciešams uzzināt, kā var veikt lietotnes atkļūdošanu un kāda informācija ir pieejama  no atmiņas izmetes.

Atmiņas izmete satur datus, kuri dod iespēju atrast kļūdas. Tāpēc atmiņas izmete var tikt pielietota, lai veiktu lietotnes atkļūdošanu, pēc neparedzētas programmas apstāšanās.
Atmiņas izmetes analīze ir efektīvs veids, kā var attālināti atrast un izlabot kļūdas bez iejaukšanās un tiešas piekļuves sistēmai.
Daudzos gadījumos, atmiņas izmete ir speciāli uzģenerēta datne, kura palīdz iegūt atmiņas stāvokli uz signāla nosūtīšanas brīdī.
Atmiņas izmete ir labi piemērota kļūdu meklēšanai, kas saistītas ar nepareizo atmiņas izmantošanu lietotnē.

Atmiņas izmete ir ELF, a.out vai cita formātā binārā  datne. 
ELF formāts ir Linux un Unix standarts priekš izpildāmām datnēm, objektu datnēm, bibliotēkām un atmiņas izmetēm.
Lai darbotos ar atmiņas izmetem ir nepieciešams, lai rīks, kurš tika izvēlēts (bibliotēka, utilītprogramma vai atkļūdotājs) atbalstītu uzģenerētās datnes formātu.
GNU gdb ir  Linux standarta atkļūdotājs \cite{MWMK}, kurš ir plaši pielietojams atmiņas izmešu analīzei. 
Turpmāk tiek apskatīta atmiņas izmetes analīze ar gdb atkļūdotāja palīdzību.

\subsection{Atmiņas izmetes atkļūdošana, izmantojot gdb }
 \label{subsec:debugg_gdb}
Ja atmiņas izmetes analīzei tika izvēlēts GNU gdb atkļūdotājs, tad pirms sākt analīzi ir nepieciešams pārliecināties ka gdb ir pareizi nokonfigurēts priekš procesora arhitektūras, no kuras bija iegūta atmiņas izmete.
To var identificēt uzreiz pēc gdb palaišanas, ar sekojošās rindiņas palīdzību: \texttt{This GDB was configured as i686-linux-gnu}.  
Lai atmiņas izmete saturētu atkļūdošanas informāciju, ir jānorāda -g opcija kompilācijas laikā.
Atkļūdošanas informācija ir uzglabāta objektu datnē un saglabā atbilstību starp izpildāmo datni un pirmkodu, ka arī uzglabā mainīgo un funkciju datu tipus.
Ja atmiņas izmete neiekļauj atkļūdošanas informāciju, tad atmiņas izmete var izdrukāt sekojošo tekstu (sk. 2.7. attēlu).

\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) p main
$ 1 = {<text variable, no debug info>} 0x80483e4 <main>
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmete nesatur atkļūdošanas informāciju}}}
\end{figure}

Kad atmiņas izmete ir uzģenerēta, tad to var apskatīt, izmantojot gdb atkļūdotāju (sk. 2.8. attēlu). 
Atkļūdotājam kā argumenti tiek padoti: izpildāms fails un atmiņas izmete. 
Izpildamām failam ir jāatbilst atmiņas izmetei, lai varētu apskatīt korektus, nesabojātus datus.

\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
$ gdb <path/to/the/binary> <path/to/the/core>
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas izmetes atvēršana, izmantojot gdb atkļūdotāju}}}
\end{figure}
%$

Gdb ļauj iegūt svarīgus datus no atmiņas izmetes. Komanda \texttt{info files} ļauj apskatīt procesa segmentus. 
Katram segmentam ir adrešu apgabals ar nosaukumu. 
Segmenti, kuru nosaukums ir "loadNNN" pieder procesam, tajos var tikt uzglabāti: statiskie dati, steks, kaudze, koplietošanas atmiņa.
Tā kā segmentu robežas ir zināmas, tad kļūst iespējams izdrukāt atmiņas saturu, kas pieder segmentiem un uzzināt kuram segmentam pieder nezināmā atmiņas adrese.

Lai izdrukātu atmiņas apgabalu var izmantot instrukciju ar sekojošo formātu: \texttt{x/nfu addr}. 
Ir nepieciešams norādīt atmiņas adresi (addr), no kuras sākt atmiņas izdruku, formātu (f), apgabala lielumu (n) un norādīt vienības lielumu (u). 
Izmantojot doto piemēru (sk. 2.9. attēlu), tiks izdrukāti 4 elementi, kuri pieder stekam, jo Intel x86 procesoros 32 bitu režīmā uz steku norāda \$esp reģistrs. 
Formātu un vienības lielumu vajag norādīt saskaņā ar gdb pamācību \cite{gdb}. 
Dotajā gadījumā atmiņa tiks izdrukāta heksadecimālā formātā (x) un vienības lielums ir vārds (word) jeb 4 baiti.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) x/4wx $esp
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas apgabala izdrukāšana}}}
\end{figure}

Lai uzzinātu kuram simbolam (funkcijai, mainīgam vai tipam) pieder adrese var izmantot sekojošo gdb instrukciju (sk. 2.10. attēlu) \cite{gdb}.
Instrukcija \texttt{print} vai \texttt{p} ļauj izdrukāt datus, bet \texttt{p/a} izdrukā absolūto adresi un relatīvo jeb adresi ar nobīdi no tuvāka simbola, kuram pieder adrese.
Tādā veidā var noteikt kuram atmiņas apgabalam pieder nezināmā adrese.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) p/a 0x54320
$3 = 0x54320 <_initialize_vx+396>
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Noteikšana, kuram simbolam pieder adrese}}}
\end{figure}

Atmiņas izmetes analīze sākas ar backtrace izdrukāšanu. 
Bactrace ir pārskats, kurš attēlo kā programma nonāca stāvoklī, kurā pabeidza savu darbību.
Tas palīdz ātri atrast instrukciju, kura bija izpildīta pēdēja un daudzos gadījumos, ļauj ātri identificēt kļūdas cēloņi.
Backrtace nesniedz patieso informāciju par funkciju, ja process tika pabeigts ārējo apstākļu dēļ, nevis tāpēc, ka bija notikusi kļūda programmā.
Katra rindiņa satur rāmi (frame). Bactrace izdruka sākas ar rāmi, kurā iekļauta funkcija, kura bija izpildīta pēdēja. 
Nākamais rāmis iekļauj funkciju, kas izsauca iepriekšējā rāmī iekļauto funkciju.
Katrai baktrace rindiņai tiek piešķirts rāmja numurs. Katrs rāmis var iekļaut: funkcijas nosaukumu, pirmkoda datnes nosaukumu, pirmkodam atbilstošo rindiņas numuru un funkcijas argumentus. 
Bactrace var tikt iegūts izmantojot gdb komandu \texttt{bactrace full} vai \texttt{bt f}. 
Pēc noklusējuma, daudzpavedienu lietotnēs gdb  rāda bactrace kārtējām pavedienam, bet pastāv iespēja iegūt arī bactrace izdruku priekš citiem pavedieniem.
Ja programma bija nokompilēta ar optimizācijas opciju, tad bactrace varētu neiekļaut funkcijas argumentus.
Šajā gadījumā funkciju argumenti varētu tikt nodoti caur CPU reģistriem, kuru vērtības ir iespējams iegūt, izmantojot komandu \texttt{info registers} vai \texttt{i r}.
Atmiņas izmetē atrodas pēdējais atmiņas stāvoklis, tāpēc CPU reģistru vērtības visticamāk tiks parakstītas.
 Ja ir nepieciešamība, tad reģistru vērtības ir iespējams atjaunot no steka.
 %ja pēc izjaukšanas (disassembling) ir redzams, ar cik lielu nobīdi tie tika saglabāti stekā.
%Izjaukšana (disassembling) ļauj izdrukāt asamblera instrukcijas noraidītai funkcijai. 
%Tas dod iespēju salīdzināt pirmkodu ar asamblera instrukcijām un tāda veidā kļūst iespējams atrast nepieciešamo mainīgo vērtības stekā.

\section{Secinājumi}
\begin{enumerate}
\item Ir izvēlētās 3 kaudzes problēmas, kuras tiks pētītās sīkāk;
\item Katrai problēmai tiek uzģenerēta atmiņās izmete;
\item Ir iegūtas zināšanas, kā var apskatīt atmiņas izmetē esošus datus;
\end{enumerate}