Šajā nodaļā ir aprakstīti atmiņas iedalīšanas paņēmieni, ir dots īss ieskāts atmiņas organizācijā un aprakstīta atmiņas pārvaldība, kuru var veikt kodols vai lietotājs.
Nodaļā ir iekļauta informācija, kura palīdz saprast kopējo atmiņas organizāciju un tās saistību ar atmiņas pieprasīšanu programmā. 
\section{Atmiņas iedalīšanas paņēmieni}
%\label{sect:Motivation}

Pirms izpildīt programmu, operētājsistēmai ir nepieciešams iedalīt resursus, tādus kā atmiņas adreses.  
Eksistē divas atmiņas iedalīšanas paņēmieni: statiskā un dinamiskā atmiņas iedalīšana (sk. 2.1. attēlu). 

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.28]{alloc}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas iedalīšanas paņēmienu klasifikācija}}}
\label{fig:alloc}
\end{figure}


\subsubsection{Statiskā atmiņas iedalīšana}
Statiskā atmiņas iedalīšana nozīme, ka atmiņa tiek iedalīta vienu reizi pirms programmas palaišanas, parasti tas notiek kompilācijas laikā.
Programmas izpildēs laikā atmiņa vairs netiek iedalīta, ka arī netiek atbrīvota. 
Statiskais atmiņas iedalīšanas paņēmiens nodrošina to, ka atmiņa tiek iedalīta statiskiem un globāliem mainīgiem, neatkarībā no tā vai mainīgais tiks izmantots pie dotajiem nosacījumiem vai nē.

\subsubsection{Dinamiskā atmiņas iedalīšana}
Dinamiskā atmiņas iedalīšana nozīme, ka atmiņa tiek iedalīta programmas izpildes laikā.
Tas var būt nepieciešams, kad atmiņas daudzums nav zināms programmas kompilācijas laikā. 
Dinamiskā atmiņas iedalīšana, var būt realizēta ar steka vai kaudzes palīdzību un var būt automātiskā vai kontrolētā \cite{SDMA}.

Automātiskā iedalīšana notiek, kad sākās programmas funkcijas izpilde. 
Šeit viens un tas pats atmiņas apgabals, kurš bija atbrīvots, var tikt izmantots  vairākas reizēs. 
Piemēram, kad tekošās funkcijas argumenti un lokālie mainīgie ir saglabāti stekā un izdzēsti pēc šīs funkcijas izpildes. 
Vērtību izdzēšana vai saglabāšana notiek, nobīdot steka norādi.
Pēc tam atbrīvotā atmiņa var būt izmantota atkārtoti. 
Priekš automātiskās atmiņas iedalīšanas, izmato steku.
Visiem funkcijas mainīgiem var piekļūt izmantojot steka norādes nobīdi, kas tiek uzglabāta reģistrā, piemēram,  
Intel x86 procesoros, 16 bitu režīmā reģistrs ir \texttt{SP}, 32 bitu režīmā - \texttt{ESP} un 64 bitu režīmā - \texttt{RSP} \cite{JCL}.
Reģistrs uzglabā adresi, kurā atrodas pēdējā uzglabāta vērtība stekā.
Steka pārpildīšana var notikt dažādu iemeslu dēļ, piemēram to var izraisīt dziļa rekursija.
 
Kontrolētā atmiņas iedalīšana nozīme, ka programma var izvēlēties patvaļīgus, brīvus atmiņas apgabalus priekš programmas datiem. 
Kontrolētā jeb manuālā atmiņas iedalīšana tiek nodrošināta ar atmiņas arēnas un kaudzes palīdzību. 
Šeit nav iespējams piekļūt datiem izmantojot vienu norādi un tās nobīdi. 
Tagad katram iedalītam atmiņas apgabalam var piekļūt tikai tad, ja ir norāde uz šo iedalīto atmiņas apgabalu. 
Gadījumos, kad norādes nav, tad adreses vairāk nav sasniedzamas un kļūst pazaudētas.
Turpmāk darbā, termins dinamiskā atmiņas iedalīšana apzīmēs kontrolēto atmiņas iedalīšanu no kaudzes.


\section{Atmiņas pārvaldība}
Kad tiek izpildīta jebkura programma, atmiņa tiek pārvaldīta divos veidos: ar kodola palīdzību vai ar lietotnes funkciju izsaukumiem, tādiem kā malloc().

\subsection{Kodola atmiņas pārvaldība}
Operētājsistēmas kodols pārvalda  visus atmiņas pieprasījumus, kas attiecās uz programmu vai programmas instancēm.
Kad lietotājs sāk programmas izpildi, tad kodols iedala atmiņas apgabalu tekošai programmai.
Pēc tam process pārvalda iedalīto apgabalu, sadalot to vairākos segmentos  \cite {atparv}: 
%\vspace{-20 pt}
\begin{itemize}
	\item   Teksts - uzglabāti dati, kuri tiek izmantoti tikai lasīšanai. Tās ir koda instrukcijas. 
    Vairākas programmas instances var izmantot šo atmiņas apgabalu.
    \item Statiskie dati - apgabals, kurā tiek uzglabāti dati ar iepriekš zināmu izmēru. Tās ir globālie un statiskie mainīgie.
    Operētājsistēma iedala šī apgabala kopiju priekš katras programmas instances atsevišķi.
    \item Atmiņas arēna - apgabals, kurā tiek uzglabāta dinamiski iedalītā un atbrīvotā atmiņa. 
    Arēna sastāv no sarakstiem ar atbrīvoto atmiņu un vienas vai vairākām kaudzēm.
    Kaudze ir apgabals, kurā atrodas visa dinamiski iedalītā atmiņa programmas izpildei.
    \item Steks - apgabals, kurā tiek uzglabāts funkciju izsaukumu stāvoklis, katram funkcijas izsaukumam. Steks aug no lielākas adreses uz mazāko. 
    Unikāla atmiņas arēna un steks iedalīti priekš katras programmas instances atsevišķi.
\end{itemize} 

 Lai palielinātu atmiņas arēnas segmenta izmēru, tiek veikts brk() sistēmas izsaukums. Izsaukums uzstāda atmiņas arēnas segmenta jauno beigu robežu. 
 Jā process nepārsniedz savu limitu, tad izsaukums atgriež 0 un arēnas segmenta lielums tiek veiksmīgi izmainīts, pretējā gadījumā tiek atgriezts -1 \cite{LINMAN}.
 Iedalīto adrešu intervālu stekam un atmiņas arēnai var atrast \texttt{/proc/<pid>/maps} datnē.
 
 
 
\subsection{Lietotāja atmiņas pārvaldība}
Lietotāja atmiņas pārvaldība ir realizēta veicot sistēmas izsaukumus un pārvaldot iegūto atmiņu, sadalot to sīkākos gabalos.
Pārvaldīt nozīme: 
\begin{enumerate}
\item sekot atmiņas gabaliem, kuri ir izmantoti,
\item sekot atbrīvotiem atmiņas gabaliem,
\item nodrošināt iespēju atkārtoti izmantot atmiņu.
\end{enumerate}

Lietotāja atmiņas pārvaldība ļauj efektīvāk pārvaldīt atmiņu, nekā tas būtu nodrošināts, katru reizi pieprasot atmiņas apgabalu ar sistēmas izsaukumiem.
Lietotāja atmiņas pārvaldība varētu būt realizēta, izmantojot dažādus atmiņas iedalītājus (allocator), piemēram, Hoard memory allocator, ptmalloc2, dlmalloc.
Dažreiz speciāli šīm nolūkam tiek izveidots individuālā iedalītāja risinājums. 
Kaut arī daži universālie iedalītāji strādā pietiekoši ātri un fragmentēšanas līmenis ir zems, individuālais risinājums var ņemt vērā lietotnei raksturīgu uzvedību un tās nodrošinās labāko veiktspēju \cite{EDBG}.

Turpmāk tiks apskatīta lietotāja atmiņas pārvaldība, izmantojot GNU C bibliotēkas funkciju palīdzību.
\begin{figure}[h]
\begin{lstlisting}
int * ptrl = new int; // C++
int * ptrl = (int *)malloc(sizeof(int)); /* C */

char * str = new char[num_elements]; // C++
char * str = (char *)malloc(sizeof(char) * num_elements); /* C */
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Dinamiskās atmiņas iedalīšana C un C++}}}
\end{figure}
Lietotājam iedalīta atmiņa atrodas kaudzē, kura tiek novietota atmiņas arēnā. 
Atmiņās arēna C valodā tiek pārvaldīta ar malloc(), realloc(), free() un calloc() funkciju palīdzību \cite {atparv}.
C++ valodā ir izmantots operators new, lai pieprasītu atmiņu.   
Attēlā 2.2. ir redzama C un C++ sintakse atmiņas pieprasīšanai izmantojot C un C++ kodu.

Vienīgais arguments malloc() funkcijai ir baitu skaits.
C programmai, lai saskaitītu cik baitu ir nepieciešams pieprasīt, ir nepieciešams zināt cik daudz vietas aizņem viens elements un kāds ir elementu skaits.
Funkcija malloc() atgriež void tipa rādītāju, tāpēc C programmās ir nepieciešams izmantot drošo tipa pārveidotāju (typecast). 
Tas ir nepieciešams, lai saglabātu atgriezto norādi lokālajā mainīgajā. Atmiņas inicializācija C kodā
var būt veikta izmantojot arī citas funkcijas, piemēram calloc() funkciju, kura atgriež atmiņas apgabalu inicializētu ar 0 vērtībām.




Funkcija free() atbrīvo ar malloc() palīdzību iedalīto atmiņu.
Lielāka atšķirība starp free() un delete ir tāda, ka vecajās free() realizācijās netiek nodrošināts atbalsts free() funkcijai, kad arguments ir null \cite{POCF}. 

Programmas rakstīšanā nejauc kopā C un C++ stilus, tāpēc priekš C++ programmas izmanto 
new un delete operatorus (sk. 2.3. attēlu), bet priekš C programmām malloc() un free.


\begin{figure}[h]
\begin{lstlisting}
delete ptrl; // C++

If( ptrl != NULL )
	free(ptrl); /* C */
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Dinamiskās atmiņas atbrīvošana C un C++}}}
\end{figure}


Ja atmiņa pēc izmantošanas netiek nekad atbrīvota, un katru reizi, izpildot vienu un to pašu koda gabalu, iedalīta no jauna, tad pieejams operētājsistēmai atmiņas daudzums ar laiku samazinās.
Sākumā sistēma paliek arvien lēnāka, pēc tam parasti notiek sistēmas apstāšanās.






\section{Atmiņas iedalīšana glibc bibliotēkā}
Darbā tiks aplūkota GNU C bibliotēkas (versija 2.3) ptmalloc2 realizācija, kuru izstrādāja Wolfram Gloger, balstoties uz Doug Lea dlmalloc realizāciju. 
Atmiņas iedalīšana sākas ar malloc() vai līdzīgo funkciju izsaukumiem no programmas koda un tiek nodrošināta ar GNU C bibliotēkas palīdzību. 




\subsection{Atmiņas arēna}

Atmiņas arēnu var nosaukt par loģisko atmiņas kolekciju. Attēlā 2.4. ir parādītas 3 arēnas, kuras ir atdalītas savā starpā ar raustītam līnijām\footnote{Attēla izveidošanai tika izmantots GNU C malloc pirmkods \cite {MALLOC} un vietnē nopublicēta shēma \cite{AMM}. Attēls demonstrē atmiņas organizāciju.}.
 Atmiņas arēnu  vienkāršotā veidā var attēlot kā viensaišu saistīto sarakstu, kurš sastāv no vienas vai vairākiem atmiņas kaudzēm. 
 Kaudze ir lineārās apgabals, kurš iekļauj sevī iedalītus vai atbrīvotus atmiņas gabalus (chunk of memory), kuri ir novietoti blakus viens otram.
 Atmiņas gabali sīkāk ir aprakstīti \ref{subsec:atminas_gabali} sadaļā.
 \begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{threads}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Arēnas GNU C bibliotēkā (versija 2.3)}}}
\end{figure}
 Gadījumos, kad gabals ir iedalīts, tad pašreiz palaists process satur norādi uz iedalīto apgabalu kaudzē. 
 Ja gabals ir atbrīvots, tad tas tiek pievienots vienā no sarakstiem uz kuriem norāda bin masīvi, kuri atrodas vienā no arēnām.
Bin masīvs un bin saraksti sīkāk ir aprakstīti \ref{subsec:bin_saraksti} sadaļā. 
 Katrā arēna ir rādītājs uz nākamo izveidoto arēnu. Pēdējā izveidotā arēna norāda uz galveno arēnu.
 Tā kā katrai arēnai var būt vairākas kaudzes, tad lai zinātu, kurai arēnai pieder kaudze, katrai kaudzei ir rādītājs uz arēnu.
 Ja kārtēja kaudze ir izlietotā un tajā nav atmiņas, tad tiek iedalīta jauna kaudze ar fiksēto 64 MB izmēru.
  Tāda veidā arēnas var tikt paplašinātas, izveidojot jaunās kaudzes un savienojot tās sava starpā.
 Jaunai kaudzei ir norāde gan uz arēnu, kurai tā pieder, gan uz iepriekšējo kaudzi.

Lai uzlabotu veiktspēju vairākpavedienu procesiem, GNU C bibliotēkā tiek izmantotas vairākas atmiņas arēnas. 
Katrs funkcijas malloc() izsaukums bloķē arēnu, no kuras tiek pieprasītā atmiņa. 
Laikā, kad arēna ir nobloķēta notiek atmiņas apgabala iedalīšana.
Kad vairākiem pavedieniem ir nepieciešams vienlaicīgi iedalīt atmiņu no kaudzes un visi pavedieni mēģina piekļūt vienai un tai pašai arēnai (tas varētu notikt dlmalloc realizācijā), tad arēnas bloķēšana var būtiski samazināt veiktspēju.
Gadījumos, kad pavedieni izmanto atmiņu no vairākām atsevišķām arēnām, piemēram kā tas notiek ptmalloc2 realizācijā, tad vienas arēnas bloķēšana neietekmē atmiņas iedalīšanu parējās arēnās un atmiņas iedalīšana var notikt paralēli.
Lai nodrošinātu labāku veiktspēju, GNU C bibliotēkā tiek izmantots modelis: katram pavedienam - viena arēna. 
Ja malloc() pirmo reizi izsaukts pavedienā, tad neatkarībā no tā vai kārtējā arēna bija nobloķēta vai nē, tiks izveidota jauna arēna.
Arēnu skaits ir ierobežots atkarībā no kodolu skaita, 32 bitu vai 64 bitu arhitektūras un mainīga MALLOC\_ARENA\_MAX vērtības.
Tā kā pavedienu skaits parasti nepārsniedz divkāršo kodolu skaitu, tad normālā gadījumā katrs pavediens izmanto atsevišķo arēnu. 
Darbība ar arēnām notiek saskaņā ar sekojošo algoritmu: 
\begin{enumerate}
\item malloc() izsaukums vēršas pie arēnas, kurai piekļuva iepriekšējo reizi,
\item ja arēna ir nobloķēta, tad malloc() vēršas pie nākamas izveidotās arēnas,
\item ja nav piekļuves nevienai arēnai, tad tiek izveidota jauna arēna un malloc() vēršas pie tās.
\end{enumerate}

Vispirms atmiņas iedalīšana sākas no galvenās arēnas (main arena). 
GNU C bibliotēkā ir globāls \texttt{malloc\_state} objekts - galvenā arēna, kura atšķiras no pārējām arēnām ar to, kā tā tiek paplašināta, izmantojot brk() nevis  mmap() sistēmas izsaukumu. 
Līdz ar galvēnās arēnas paplašināšanu, tiek paplašināts arī procesa arēnas segments.
Bet mmap() sistēmas izsaukums paplašina pārējās dinamiskās arēnas daudzpavedienu lietotnēs, ka arī nodrošina lielu atmiņas bloku iedalīšanu mmap apgabalā.
Mazākais gabals, kurš pēc noklusējuma tiks iedalīts ar mmap()  ir vienāds ar 128 kilobaitiem. 
Sākot ar GNU C bibliotēkas 2.18 versiju, mazāko gabalu, kurš tiks iedalīts ar mmap() var uzdot ar M\_MMAP\_THRESHOLD konstanti.





 \subsection{Atbrīvotās atmiņas organizācija}
 \label{subsec:bin_saraksti}
Realizācijā ptmalloc2 ir masīvi, kuri uzglabā norādes uz bin sarakstiem.
Bin saraksti ir struktūras, kuras uzglabā atbrīvotus atmiņas gabalus arēnā, līdz brīdim, kad tie tiks iedalīti procesam atkārtoti.
Atbrīvots atmiņas gabals ne vienmēr tiks uzreiz atgriezts operētājsistēmai (sīkāk šī situācija ir aprakstīta \ref{sec:peak_mem} apakšnodaļā), bet var tikt defragmentēts vai sapludināts ar pārējiem gabaliem un ievietots sarakstā. 
Ja atmiņa bija atbrīvota, tad atmiņas gabali tiks uzglabāti vienā no bin saistītiem sarakstiem.
Eksistē divi bin saraksta veidi: ātrais (fastbin) un parastais (normal bin).


Ātrais saraksts ir paredzēts bieži izmantotu, mazu atmiņas gabalu glabāšanai.
Pēc noklusējuma ātro atmiņas gabalu izmērs nepārsniedz 64 baitus (sk. 2.5. attēlu), bet to var palielināt līdz 80 baitiem \cite {MALLOC}. 
Tas varētu būt nepieciešams, ja programma ir bieži izmantotas struktūras, kuru izmērs pārsniedz 64 baitus.
Atmiņas gabali atrodas viensaišu sarakstā un nav sakārtoti, jo katrā bin sarakstā elementi ir ar vienādu izmēru.
Lai samazinātu fragmentācijas iespējamību, programma, kad pieprasa vai atbrīvo lielus atmiņas gabalus var sapludināt atmiņas gabalus, kuri atrodas fastbin sarakstā.
Piekļuve tādiem atmiņas gabaliem ir ātrāka nekā piekļuve parastiem gabaliem. 
Fastbin saraksta elementi ir apstrādāti pēdējais iekšā pirmais āra (jeb LIFO) kārtībā \cite {Binning}.
Kad tiek pieprasīta atmiņa no fastbin saraksta, tad jebkurš atmiņas gabals tiek atgriezts konstantā laikā  \cite {ACCA}.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.31]{fastbins}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Ātrais saraksts}}}
\label{fig:fastbin}
\end{figure}

Parastie saraksti var būt sadalīti 3 veidos. Pirmkārt, bin saraksts, kurš uzglabā nesakārtotus gabalus, kuri nesen bija atbrīvoti.  
Pēc tam tie tiks novietoti vienā no atlikušiem bin sarakstiem: mazā vai lielā izmēra. 
Mazā izmēra saraksts uzglabā atmiņas gabalus, kuri ir mazāki vai vienādi ar 512 baitiem. 
Vairāki ātrie gabali var būt sapludināti un uzglabāti dotajā sarakstā. 
Lielā izmēra saraksts uzglabā atmiņas gabalus, kuri ir lielāki par 512 baitiem, bet mazāki par 128 kilobaitiem. 
Lielā izmēra saraksta elementi ir sakārtoti pēc izmēra un ir iedalīti pirmais iekšā, pirmais ārā (jeb FIFO) kārtībā \cite {Binning}. 
Gabali, kuru izmērs ir lielāks par 128 kilobaitiem netiek uzglabāti bin sarakstos, jo tiek iedalīti, izmantojot mmap(). 




\subsection{Atmiņas gabali}
\label{subsec:atminas_gabali}


Eksistē divu veidu atmiņas gabali: parastie (normal chunk) un ātrie (fast chunk) gabali. 
Ātrie gabali ir mazā izmērā (parasti līdz 64 baitiem) un pieder ātrajām sarakstām, bet parastie gabali - parastajām sarakstam. 
Ātrie un parastie gabali, tiek izmantoti, lai nodrošinātu atmiņas iedalīšanu no arēnas segmenta.
Atmiņas gabala fiziska struktūra ir vienāda abu veidu gabaliem, bet ir atkarīga no stāvokļa un var tikt interpretēta dažādi.
Atmiņa no kaudzēs tiek iedalīta, izmantojot malloc\_chunk struktūru (sk. 2.6. attēlu). 
Sīkāk struktūras malloc\_chunk elementi ir aprakstīti tabulā 2.1.

\begin{table}[H]
\caption{\textbf{\fontsize{11}{12}\selectfont {\\ Chunk struktūras elementu apraksts}}} 
\label{table:kysymys}
\centering
	\begin{tabular}{|l|l|r|p{5cm}|}
	  \hline
	Elements & Nozīme \\
	\hline
	  INTERNAL\_SIZE\_T               prev\_size & Iepriekšēja gabala izmērs (baitos), ja tas bija atbrīvots\\
      \hline
      INTERNAL\_SIZE\_T               size & Kārtējā gabala izmērs (baitos) \\
      \hline
      struct malloc\_chunk*          fd & Rādītājs uz nākamo atbrīvoto gabalu, ja kārtējais  \\
                                                     & gabals ir atbrīvots un pievienots dubultsaišu bin \\
                                                     & sarakstām\\
      \hline
      struct malloc\_chunk*          bk & Rādītājs uz iepriekšējo atbrīvoto gabalu, ja kārtējais  \\
                                                     & gabals ir atbrīvots un pievienots dubultsaišu bin \\
                                                     & sarakstām\\
    \hline
	\end{tabular}
\end{table}
\begin{figure}[h]
\begin{lstlisting}
struct malloc_chunk  {
                INTERNAL_SIZE_T               prev_size;
                INTERNAL_SIZE_T               size;
                struct malloc_chunk*          fd;
                struct malloc_chunk*          bk;
 }
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas gabala struktūra}}}
\end{figure}

Katru reizi ir iedalīts lielāks atmiņas gabals nekā pieprasīts ar malloc() funkciju.
Tas ir nepieciešams, lai varētu saglabāt uzturēšanai nepieciešamo informāciju. 
Iedalītam gabalam uzturēšanas informācija ir divas INTERNAL\_SIZE\_T tipa vērtības, kas vienādas ar 4*2 vai 8*2 baitiem. 
Tas ir atkarīgs no tā, kāda vērtība ir piešķirta INTERNAL\_SIZE\_T makrodefinīcijai, 4 vai 8 baiti.
Ar INTERNAL\_SIZE\_T var uzdot iekšējo vārda izmēru (word-size), kurš pēc noklusējuma ir vienāds ar size\_t izmēru.
Datoriem ar 64 bitu tehnoloģiju, 4 baitu vērtības piešķiršana makrodefinīcijai  var samazināt aizņemtās atmiņas daudzumu, bet ierobežo lielāko iespējamo gabala izmēru.
Tā kā 4 baitos nevar saglabāt skaitli, kas ir vienāds vai lielāks par \(2^{32}\), tad laukā \texttt{prev\_size} un \texttt{size} vērtībai ir jābūt mazākai par šo ierobežojošo vērtību.
Kad gabals ir iedalīts, tad uzturēšanas informācijai ir izmantoti divas INTERNAL\_SIZE\_T tipa vērtības un, kad gabals ir atbrīvots, tad  dubultsaišu saraksta uzturēšanai, papildus tiek izmantoti divi rādītāji (fd un bk) uz iepriekšējo un nākamo \texttt{malloc\_chunk} struktūras objektiem. 
Kopējais atmiņas gabala uzturēšanai izmantotais datu izmērs var būt 16 baiti (ja INTERNAL\_SIZE\_T un rādītāja izmērs ir 4 baiti), 24 baiti (ja INTERNAL\_SIZE\_T ir 4/8 baiti un rādītāja izmērs ir 8/4 baiti) vai 32 baiti (ja INTERNAL\_SIZE\_T un rādītāja izmērs ir 8 baiti).  
Otrs iemesls kāpēc ir iedalīts lielāks atmiņas daudzums ir izlīdzināšana skaitlim, kas ir  2*sizeof(INTERNAL\_SIZE\_T) reizinājums. Šīs skaitlis ir vienāds ar 8 baitu izlīdzinājumu, ja  makrodefinīcijas INTERNAL\_SIZE\_T vērtība  ir vienāda ar 4 baitiem \cite {MALLOC}.  

 \begin{figure}[h]
\begin{center}
\includegraphics[scale=0.22]{chunks}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas gabalu struktūra}}}
\label{fig:chunks}
\end{figure}


No kreisās pusēs attēlots (sk. 2.7. attēlu) \cite{CHOFM} atmiņas gabals, kurš bija iedalīts procesam, no labās, tās, kurš bija atbrīvots.
Abos gadījumos rādītājs chunk attēlo atmiņas gabalu sākumu. Pēc šī radītāja var iegūt iepriekšēja gabala izmēru, ja iepriekšējais gabals bija atbrīvots.
Gadījumā, kad iepriekšējais gabals ir iedalīts, tad chunk norāda uz daļu no iepriekšēja gabala novietotiem lietotāja datiem. 
Pēc tam seko kārtēja gabala izmērs un 3 biti ar meta informāciju. 


Tā kā notiek izlīdzināšana 2*sizeof(INTERNAL\_SIZE\_T), kas ir vienāda 8 - ka vai 16 - ka  reizinājumam, tad 3 pēdējie biti netiek izmantoti izmēra glabāšanai. 
Šos bitus izmanto kontroles zīmēm. Katram bitam ir sava nozīme, kura aprakstīta 2.2. tabulā.
Rādītājs mem ir malloc() funkcijas atgriežamā vērtība, jeb radītājs uz iedalīto atmiņas apgabalu. Iedalīts apgabals stiepjas līdz atmiņas gabala struktūras beigām.
Pēc šī rādītāja var tikt uzglabāti dati, kad atmiņa ir iedalīta un, ja tā ir atbrīvota, tad šeit tiks uzglabāti divi radītāji uz nākamo un iepriekšējo atbrīvotiem gabaliem, kas atrodas sarakstā. 


  \begin{table}[H]
\caption{\textbf{\fontsize{11}{12}\selectfont {\\ Chunk gabala kontroles zīmes}}} 
\label{table:kysymys}
\centering
	\begin{tabular}{|c|l|r|p{5cm}|}
	  \hline
	Kontroles zīme & Nozīme \\
	\hline
	  A & gabals nepieder galvenajai arēnai \\
      \hline
      M & gabals tiek iedalīts ar mmap() sistēmas izsaukumu \\
      \hline
      P & iepriekšējais atmiņas gabals tiek izmantots  \\
    \hline
	\end{tabular}
\end{table}



Eksistē divi citi atmiņas gabali (top chunk un last\_remainder), kuriem ir īpaša nozīme. 
Top chunk ir atmiņas gabals, kuram ir kopīga robeža ar atmiņas arēnas segmentu.
Top gabals ir izmantots gadījumos, kad nav piemērotu gabalu bin sarakstos, kuri apmierina pieprasījumu vai varētu būt saplūdināti, lai apmierinātu pieprasījumu.
Sākotnēji atmiņās iedalīšana sākas ar top gabalu, bet top gabals nodrošina arī pēdējo iespēju iedalīt pieprasīto atmiņas daudzumu.
Top gabals var mainīt savu izmēru. Tas saraujas, kad atmiņa ir iedalīta un izstiepjas, kad atmiņa ir atbrīvota blakus top gabala objektam. 
Ja ir pieprasīta atmiņa, kas ir lielāka par pieejamo, tad top gabals var paplašināties ar brk() palīdzību.
Top gabals ir līdzīgs jebkuram citam atmiņas apgabalam. 
Galvenā atšķirība ir lietotāja datu sekcija, kura netiek izmantota, P kontroles zīme, kura vienmēr norāda, ka iepriekšējais gabals ir izmantots, ka arī speciāla top gabala apstrāde, lai nodrošinātu, ka top chunk vienmēr eksistē \cite {BLACKHAT}.

Last\_remainder ir vel viens atmiņas gabals ar īpašu nozīmi.
Tas ir izmantots gadījumos, kad ir pieprasīts mazs atmiņas gabals, kas neatbilst nevienam bin saraksta elementam. 
Last\_remainder ir dalījuma atlikums, kurš izveidojās pēc lielāka gabala sadalīšanas, lai apmierinātu pieprasījumu pēc maza gabala  \cite {BLACKHAT}.


%\section{Atmiņas statistika}

%Linux nodrošina malloc\_stats() funkciju, kura izdrukā atmiņas statistiku standartā kļūdu plūsmā stderr. 
%Katrai atmiņas arēnai  funkcija izdruka kopējo iedalītās atmiņas daudzumu \texttt{(system bytes)} un pašreiz izmantoto atmiņas daudzumu \texttt{(in use bytes)}.
%Ir pieejama kopēja statistikā visām arēnām pēc abiem iepriekš minētiem parametriem, ka arī tiek izdrukāts maksimālais bloku un baitu daudzums, kurš bija iedalīts ar mmap() sistēmas izsaukumu. 

Zinot atmiņas gabala struktūru, var uzrakstīt kodu C valodā, kurš izdrukās iedalītā gabala izmēru (sk. 2.8. attēlu).
\begin{figure}[h]
\begin{lstlisting}
 #include <stdio.h>
 #include <malloc.h>

 int main () {
     char * ptrl;
     int chunk_size;

     ptrl = malloc(4);
 
     /* get value of chunk size (the second malloc_chunk element) */
     chunk_size = *((char *) ptrl - sizeof(size_t));
     /* the lower 3-bits are used as metadata */
     chunk_size = chunk_size - (chunk_size & 7);
 
     printf("size = %d\n", chunk_size);
     free(ptrl);
 
     return 0;
 }
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Izmēra noteikšana iedalītām gabalam}}}
\end{figure}

Algoritms ir sekojošs: 
\begin{enumerate}
\item ar malloc() tiek iedalīts atmiņas apgabals,
\item  tiek iegūta size elementa vērtība (objektam ar malloc\_chunk struktūru),
\item  tiek atņemtas A, M, P kontroles zīmes 111 = 7 un iegūts iedalītā atmiņas  gabala izmērs,
\item  tiek atbrīvota atmiņa.
\end{enumerate}



