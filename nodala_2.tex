Šajā nodaļā ir aprakstīti atmiņas iedalīšanas paņēmieni, ir dots īss ieskāts atmiņas organizācijā un aprakstīta atmiņas pārvaldība, kuru var veikt kodols vai lietotājs.
Šajā nodaļā tiek iekļauta informācija, kura palīdz saprast kopējo atmiņas organizācijas mehānismu un tās saistību ar programmu, ja programmā ir izmantota dinamiskā (kontrolētā) atmiņas iedalīšana. 
\section{Atmiņas iedalīšanas paņēmieni}
%\label{sect:Motivation}

Pirms izpildīt programmu, operētājsistēmai ir nepieciešams iedalīt resursus, tādus kā atmiņas adreses.  
Eksistē divas atmiņas iedalīšanas paņēmieni: statiskā un dinamiskā atmiņas iedalīšana (sk. 2.1. attēlu). 

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.28]{alloc}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas iedalīšanas paņēmienu klasifikācija}}}
\label{fig:alloc}
\end{figure}


\subsubsection{Statiskā atmiņas iedalīšana}
Statiskā atmiņas iedalīšana nozīme, ka atmiņa tiek iedalīta vienu reizi pirms programmas palaišanas, parasti tas notiek kompilācijas laikā.
Programmas izpildēs laikā atmiņa vairs netiek iedalīta, ka arī netiek atbrīvota. 
Statiskais atmiņas iedalīšanas paņēmiens nodrošina to, ka atmiņa tiek iedalīta statiskiem un globāliem mainīgiem, neatkarībā no tā vai mainīgais tiks izmantots pie dotajiem nosacījumiem vai nē.

\subsubsection{Dinamiskā atmiņas iedalīšana}
Dinamiskā atmiņas iedalīšana nozīme, ka atmiņa tiek iedalīta programmas izpildes laikā.
Tas var būt nepieciešams, kad atmiņas daudzums nav zināms programmas kompilācijas laikā. 
Dinamiskā atmiņas iedalīšana, var būt realizēta ar steka vai kaudzes palīdzību un var būt automātiskā vai kontrolētā \cite{SDMA}.

Automātiskā iedalīšana notiek, kad sākās programmas funkcijas izpilde. 
Šeit viens un tas pats atmiņas apgabals, kurš bija atbrīvots, var tikt izmantots  vairākas reizēs. 
Piemēram, kad tekošās funkcijas argumenti un lokālie mainīgie ir saglabāti stekā un izdzēsti pēc šīs funkcijas izpildes. 
Vērtību izdzēšana vai saglabāšana notiek, nobīdot steka norādi.
Pēc tam atbrīvotā atmiņa var būt izmantota atkārtoti. 
Priekš automātiskās atmiņas iedalīšanas, izmato steku.
Visiem funkcijas mainīgiem var piekļūt izmantojot steka norādes nobīdi, kas tiek uzglabāta reģistrā, piemēram,  
Intel x86 procesoros, 16 bitu režīmā reģistrs ir \texttt{SP}, 32 bitu režīmā - \texttt{ESP} un 64 bitu režīmā - \texttt{RSP} \cite{JCL}.
Reģistrs uzglabā adresi, kurā atrodas pēdējā uzglabāta vērtība stekā.
Steka pārpildīšana var notikt dažādu iemeslu dēļ, piemēram to var izraisīt dziļa rekursija.
 
 Kontrolētā atmiņas iedalīšana nozīme, ka programma var izvēlēties patvaļīgus, brīvus atmiņas apgabalus priekš programmas datiem. 
Kontrolētā jeb manuālā atmiņas iedalīšana ir realizēta ar kaudzes palīdzību. 
Šeit nav iespējams piekļūt datiem izmantojot vienu norādi un tās nobīdi. 
Tagad katram izdalītam atmiņas apgabalam var piekļūt tikai tad, ja ir norāde uz šo iedalīto atmiņas apgabalu. 
Gadījumos, kad norādes nav, tad adreses vairāk nav sasniedzamas un kļūst pazaudētas.


\section{Atmiņas pārvaldība}
Kad tiek izpildīta jebkura programma, atmiņa tiek pārvaldīta divos veidos: ar kodola palīdzību vai ar lietotnes funkciju izsaukumiem, tādiem kā malloc().

\subsection{Kodola atmiņas pārvaldība}
Operētājsistēmas kodols pārvalda  visus atmiņas pieprasījumus, kas attiecās uz programmu vai programmas instancēm.
Kad lietotājs sāk programmas izpildi, tad kodols iedala atmiņas apgabalu tekošai programmai.
Pēc tam programma pārvalda iedalīto apgabalu, sadalot to vairākos segmentos: 
%\vspace{-20 pt}
\begin{itemize}
	\item   Teksts - uzglabāti dati, kuri tiek izmantoti tikai lasīšanai. Tās ir koda instrukcijas. 
    Vairākas programmas instances var izmantot šo atmiņas apgabalu.
    \item Statiskie dati - apgabals, kurā tiek uzglabāti dati ar iepriekš zināmu izmēru. Tās ir globālie un statiskie mainīgie.
    Operētājsistēma iedala šī apgabala kopiju priekš katras programmas instances atsevišķi.
    \item Atmiņas arēna - apgabals, kurā tiek uzglabāta dinamiski iedalītā atmiņa. Atmiņas arēna sastāv no kaudzes un atbrīvotās atmiņas sarakstiem.
    Kaudze ir apgabals, kurā atrodas visa iedalītā atmiņa programmas izpildei.
    \item Steks - apgabals, kurā tiek uzglabāts funkciju izsaukumu stāvoklis, katram funkcijas izsaukumam. Steks aug no lielākas adreses uz mazāko. 
    Unikāla atmiņas arēna un steks iedalīti priekš katras programmas instances atsevišķi.
\end{itemize} 

 Lai palielinātu atmiņas arēnas izmēru, tiek veikts brk() sistēmas izsaukums. Izsaukums uzstāda atmiņas arēnas segmenta jauno beigu robežu. 
 Jā process nepārsniedz savu limitu, tad izsaukums atgriež 0 un arēnas segmenta lielums tiek veiksmīgi izmainīts, pretējā gadījumā tiek atgriezts -1.
 Iedalīto adrešu intervālu stekam un atmiņas arēnai var atrast \texttt{/proc/<pid>/maps} datnē.
\subsection{Lietotājs atmiņas pārvaldība}
Lietotājam iedalīta atmiņa atrodas kaudzē, kura tiek novietota atmiņas arēnā. 
Atmiņās arēna C valodā tiek pārvaldīta ar malloc(), realloc(), free() un calloc() funkciju palīdzību \cite {atparv}.
C++ valodā ir izmantots operators new, lai pieprasītu atmiņu.   
Attēlā 2.2. ir redzama C un C++ sintakse atmiņas pieprasīšanai izmantojot C un C++ kodu.
Vienīgais arguments malloc() funkcijai ir baitu skaits.
C programmai, lai saskaitītu cik baitu ir nepieciešams pieprasīt, ir nepieciešams zināt cik daudz vietas aizņem viens elements un kāds ir elementu skaits.
Funkcija malloc() atgriež void tipa rādītāju, tāpēc C programmās ir nepieciešams izmantot drošo tipa pārveidotāju (typecast). 
Tas ir nepieciešams, lai saglabātu atgriezto norādi lokālajā mainīgajā. Atmiņas inicializācija C kodā
var būt veikta izmantojot arī citas funkcijas, piemēram calloc() funkciju, kura atgriež atmiņas apgabalu inicializētu ar 0 vērtībām.

\begin{figure}[h]
\begin{lstlisting}
int * ptrl = new int; // C++
int * ptrl = (int *)malloc( sizeof(int) ); /* C */

char * str = new char[num_elements]; // C++
char * str = (char *)malloc( sizeof(char) * num_elements ); /* C */
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Dinamiskās atmiņas iedalīšana C un C++}}}
\end{figure}


Funkcija free() atbrīvo ar malloc() palīdzību iedalīto atmiņu.
Lielāka atšķirība starp free() un delete ir tāda, ka vecajās free() realizācijās netiek nodrošināts atbalsts free() funkcijai, kad arguments ir null \cite{POCF}. 

Programmas rakstīšanā nejauc kopā C un C++ stilus, tāpēc priekš C++ programmas izmanto 
new un delete operatorus (sk. 2.3. attēlu), bet priekš C programmām malloc() un free.


\begin{figure}[h]
\begin{lstlisting}
delete ptrl; // C++

If( ptrl != NULL )
	free(ptrl); /* C */
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Dinamiskās atmiņas atbrīvošana C un C++}}}
\end{figure}


Ja atmiņa pēc izmantošanas netiek nekad atbrīvota, un katru reizi, izpildot vienu un to pašu koda gabalu, iedalīta no jauna, tad pieejams operētājsistēmai atmiņas daudzums ar laiku samazinās.
Sākumā sistēma paliek arvien lēnāka, pēc tam parasti notiek sistēmas apstāšanās.






\section{Atmiņas iedalīšana glibc bibliotēkā}
Darbā tiks aplūkota GNU C bibliotēkas (versija 2.3) ptmalloc2 realizācija, kuru izstrādāja Wolfram Gloger, balstoties uz Doug Lea dlmalloc realizāciju. 
Atšķirībā no dlmalloc, ptmalloc2 izmanto atsevišķas arēnas priekš pavedieniem.
Tāpēc atmiņas iedalīšana var notikt vienlaicīgi vairākos pavedienos.
Atmiņas iedalīšana sākas ar malloc() izsaukumu no programmas koda un tiek nodrošināta ar GNU C bibliotēkas palīdzību. 
GNU C bibliotēka ļauj efektīvāk pārvaldīt no kodola iedalīto atmiņas apgabalu, nekā tas būtu nodrošināts, katru reizi pieprasot atmiņas apgabalu ar brk() sistēmas izsaukumu.

\subsection{Atmiņas chunk gabali}
Atmiņa no kaudzēs tiek iedalīta, izmantojot malloc\_chunk struktūru (sk. 2.4. attēlu). 
Struktūras malloc\_chunk elementi ir aprakstīti tabulā 2.1.
\begin{figure}[h]
\begin{lstlisting}
struct malloc_chunk  {
                INTERNAL_SIZE_T               prev_size;
                INTERNAL_SIZE_T               size;
                struct malloc_chunk*          fd;
                struct malloc_chunk*          bk;
 }
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas gabala struktūra}}}
\end{figure}

Katru reizi ir iedalīts lielāks atmiņas gabals nekā pieprasīts ar malloc() funkciju.
Tas ir nepieciešams, lai varētu saglabāt uzturēšanai nepieciešamo informāciju. 
Iedalītam gabalam uzturēšanas informācija ir divas INTERNAL\_SIZE\_T tipa vērtības, kas vienādas ar 8 vai 16 baitiem. 
Tas ir atkarīgs no tā, kāda vērtība ir piešķirta INTERNAL\_SIZE\_T makrodefinīcijai (4 vai 8 baiti).
\begin{table}[H]
\caption{\textbf{\fontsize{11}{12}\selectfont {\\ Chunk gabala struktūras apraksts}}} 
\label{table:kysymys}
\centering
	\begin{tabular}{|l|l|r|p{5cm}|}
	  \hline
	Elements & Nozīme \\
	\hline
	  INTERNAL\_SIZE\_T               prev\_size & Iepriekšēja gabala izmērs (baitos), ja tas bija atbrīvots\\
      \hline
      INTERNAL\_SIZE\_T               size & Kārtējā gabala izmērs (baitos) \\
      \hline
      struct malloc\_chunk*          fd & Rādītājs uz nākamo atbrīvoto gabalu, ja kārtējais  \\
                                                     & gabals ir atbrīvots un pievienots dubultsaišu bin \\
                                                     & sarakstām\\
      \hline
      struct malloc\_chunk*          bk & Rādītājs uz iepriekšējo atbrīvoto gabalu, ja kārtējais  \\
                                                     & gabals ir atbrīvots un pievienots dubultsaišu bin \\
                                                     & sarakstām\\
    \hline
	\end{tabular}
\end{table}
Ar INTERNAL\_SIZE\_T var uzdot iekšējo vārda izmēru (word-size), kurš pēc noklusējuma ir vienāds ar size\_t izmēru.
Datoriem ar 64 bitu tehnoloģiju, 4 baitu vērtības piešķiršana makrodefinīcijai  var samazināt aizņemtās atmiņas daudzumu, bet ierobežo lielāko iedalīto gabala izmēru.
Tā kā 4 baitos nevar saglabāt skaitli, kas ir vienāds vai lielāks par \(2^{32}\), tad laukā \texttt{prev\_size} un \texttt{size} vērtībai ir jābūt mazākai par ierobežojošo vērtību.
Ja gabals ir iedalīts, tad uzturēšanas informācijai ir izmantoti divas INTERNAL\_SIZE\_T tipa vērtības un, ja gabals ir atbrīvots, tad  dubultsaišu saraksta uzturēšanai, papildus tiek izmantoti divi rādītāji (fd un bk) uz iepriekšējo un nākamo \texttt{malloc\_chunk} objektiem. 
Kopējais atmiņas gabala izmērs var būt 16 baiti (ja INTERNAL\_SIZE\_T un rādītāja izmērs ir 4 baiti), 24 baiti (ja INTERNAL\_SIZE\_T ir 4/8 baiti un rādītāja izmērs ir 8/4 baiti) vai 32 baiti (ja INTERNAL\_SIZE\_T un rādītāja izmērs ir 8 baiti).  
Otrs iemesls kāpēc ir iedalīts lielāks atmiņas daudzums ir izlīdzināšana skaitlim, kas ir  2*sizeof(INTERNAL\_SIZE\_T) reizinājums. Šīs skaitlis ir vienāds ar 8 baitu izlīdzinājumu, ja  makrodefinīcijas INTERNAL\_SIZE\_T vērtība  ir vienāda ar 4 baitiem \cite {MALLOC}.  


Eksistē divu veidu atmiņas gabali: parastie (normal chunk) un ātrie (fast chunk) gabali. 
Ātrie gabali ir mazā izmērā (parasti līdz 64 baitiem) un pieder viensaišu atbrīvoto elementu ātrajām sarakstām (fastbin). 
Parastie gabali pieder dubultsaišu parastajām sarakstam (normal bin). 
Abu veidu atmiņas gabali tiek izmantoti, lai nodrošinātu atmiņas iedalīšanu.
Atmiņas gabala fiziska struktūra ir vienāda gan parastiem, gan ātriem gabaliem, bet ir atkarīga no stāvokļa un var tikt interpretēta dažādi.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.22]{chunks}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas gabalu struktūra}}}
\label{fig:chunks}
\end{figure}

No kreisās pusēs attēlots (sk. 2.5. attēlu) atmiņas gabals, kurš bija iedalīts procesam, no labās, tās, kurš bija atbrīvots.
Abos gadījumos rādītājs chunk attēlo atmiņas gabalu sākumu. Pēc šī radītāja var iegūt iepriekšēja gabala izmēru, ja iepriekšējais gabals bija atbrīvots.
Gadījumā, kad iepriekšējais gabals paliek iedalīts, tad pēc chunk rādītāja atrodas daļa no iepriekšēja gabala lietotāja datiem. 
Pēc tam seko kārtēja gabala izmērs un 3 biti ar meta informāciju. 
Tā kā notiek izlīdzināšana 2*sizeof(INTERNAL\_SIZE\_T), kas ir vienāda 8 - ka vai 16 - ka  reizinājumam, tad 3 pēdējie biti netiek izmantoti izmēra glabāšanai. 
Šos bitus izmanto kontroles zīmēm. Katram bitam ir sava nozīme, kura aprakstīta tabulā (sk. 2.2. tabulu).
Sistēmas izsaukumu mmap() izmanto, lai iegūtu atmiņas apgabalu, kas ir lielāks par 128 kilobaitiem. 
 \begin{table}[H]
\caption{\textbf{\fontsize{11}{12}\selectfont {\\ Chunk gabala kontroles zīmes}}} 
\label{table:kysymys}
\centering
	\begin{tabular}{|c|l|r|p{5cm}|}
	  \hline
	Kontroles zīme & Nozīme \\
	\hline
	  A & gabals nepieder galvenai arēnai \\
      \hline
      M & gabals tiek iedalīts ar mmap() sistēmas izsaukumu \\
      \hline
      P & iepriekšējais atmiņas gabals tiek izmantots  \\
    \hline
	\end{tabular}
\end{table}

Rādītājs mem ir malloc() funkcijas atgriežamā vērtība, jeb radītājs uz iedalīto atmiņas apgabalu. Iedalīts apgabals stiepjas līdz atmiņas gabala struktūras beigām.
Pēc šī rādītāja var tikt uzglabāti dati, kad atmiņa ir iedalīta un, ja tā ir atbrīvota, tad šeit tiks uzglabāti divi radītāji uz nākamo un iepriekšējo atbrīvotiem gabaliem, kas atrodas sarakstā. 
 

 \subsection{Bin saraksti ptmalloc2 versijā}
Bin masīvs uzglabā norādes uz bin sarakstiem.
Bin saraksti ir struktūras, kuras uzglabā atbrīvotus atmiņas gabalus, līdz brīdim, kad tie tiks iedalīti procesam atkārtoti.
Ja atmiņa bija atbrīvota, tad atmiņas gabali tiks uzglabāti vienā no bin saistītiem sarakstiem.
Atbrīvots atmiņas gabals netiek atgriezts operētājsistēmai, bet ir defragmentēts vai sapludināts ar pārējiem gabaliem un ievietots sarakstā. 
Eksistē divi bin saraksta veidi: ātrais (fastbin) un parastais (normal bin).

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{fastbins}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Ātrais saraksts}}}
\label{fig:fastbin}
\end{figure}

Ātrais saraksts ir paredzēts bieži izmantotu, mazu atmiņas gabalu glabāšanai.
Pēc noklusējuma ātro atmiņas gabalu izmērs nepārsniedz 64 baitus (sk. 2.6. attēlu), bet to var palielināt līdz 80 baitiem \cite {MALLOC}. 
Tas varētu būt nepieciešams, ja programma ir bieži izmantotas struktūras, kuru izmērs pārsniedz 64 baitus.
Atmiņas gabali atrodas viensaišu sarakstā un nav sakārtoti, jo katrā bin sarakstā ir elementi ar vienādu izmēru.
Lai samazinātu fragmentācijas iespējamību, programma, kad pieprasa vai atbrīvo lielus atmiņas gabalus var sapludināt atmiņas gabalus, kuri atrodas fastbin sarakstā.
Piekļuve tādiem atmiņas gabaliem ir ātrāka nekā piekļuve parastiem gabaliem. 
Fastbin saraksta elementi ir apstrādāti pēdējais iekšā pirmais āra (jeb LIFO) kārtībā \cite {Binning}.
Kad tiek pieprasīta atmiņa no fastbin saraksta, tad jebkurš atmiņas gabals tiek atgriezts konstantā laikā  \cite {ACCA}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{normalbins}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Parastais saraksts}}}
\label{fig:normalbins}
\end{figure}

Parastie saraksti (sk. 2.7. attēlu) var būt sadalīti 3 veidos. Pirmkārt, bin saraksts, kurš uzglabā nesakārtotus gabalus, kuri nesen bija atbrīvoti.  
Pēc tam tie tiks novietoti vienā no atlikušiem bin sarakstiem: mazā vai lielā izmēra. 
Mazā izmēra saraksts uzglabā atmiņas gabalus, kuri ir mazāki par 512 baitiem. 
Vairāki ātrie gabali var būt sapludināti un uzglabāti dotajā sarakstā. 
Lielā izmēra saraksts uzglabā atmiņas gabalus, kuri ir lielāki par 512 baitiem, bet mazāki par 128 kilobaitiem. 
Gabali, kuru izmērs ir lielāks par 128 kilobaitiem netiek uzglabāti bin sarakstos, jo tiek iedalīti, izmantojot mmap().
Lielā izmēra saraksta elementi ir sakārtoti pēc izmēra un ir iedalīti pirmais iekšā, pirmais ārā (jeb FIFO) kārtībā \cite {Binning}. 
Eksistē divi citi atmiņas gabali (top chunk un last\_remainder), kuriem ir īpaša nozīme un tie netiek uzglabāti bin sarakstos. 



Top chunk ir atmiņas gabals, kurš ierobežo pieejamās atmiņas daudzumu.
Tas ir izmantots gadījumos, kad nav piemērotu gabalu bin sarakstos, kuri apmierina pieprasījumu vai varētu būt saplūdināti, lai apmierinātu pieprasījumu.
Top chunk nodrošina pēdējo iespēju iedalīt pieprasīto atmiņas daudzumu.
Top chunk var mainīt savu izmēru. Tas saraujas, kad atmiņa ir iedalīta un izstiepjas, kad atmiņa ir atbrīvota blakus top chunk struktūrai. 
Ja ir pieprasīta atmiņa, kas ir lielāka par pieejamo, tad top chunk var paplašināties ar brk() palīdzību.
Top chunk ir līdzīgs jebkuram citam atmiņas apgabalam. 
Galvenā atšķirība ir lietotāja datu sekcija, kura netiek izmantota, ka arī speciāla top chunk apstrāde, lai nodrošinātu, ka top chunk vienmēr eksistē.

Last\_remainder ir vel viens atmiņas gabals ar īpašu nozīmi.
Tas ir izmantots gadījumos, kad ir pieprasīts mazs atmiņas gabals, kas neatbilst nevienam bin saraksta elementam. 
Last\_remainder ir dalījuma atlikums, kurš izveidojās pēc lielāka gabala sadalīšanas, lai apmierinātu pieprasījumu pēc maza gabala  \cite {BLACKHAT}.

\subsection{Atmiņas arēna}

Lai uzlabotu veiktspēju vairākpavedienu procesiem, GNU C bibliotēkā tiek izmantotas vairākas atmiņas arēnas. 
Katrs funkcijas malloc() izsaukums bloķē izmantoto arēnu. Laikā, kad arēna ir nobloķēta notiek atmiņas apgabala iedalīšana.
Kad vairākiem pavedieniem ir nepieciešams vienlaicīgi iedalīt atmiņu no kaudzes, arēnas bloķēšana var būtiski samazināt veiktspēju.
Gadījumos, kad pavedieni izmanto atmiņu no vairākām atsevišķām arēnām, tad vienas arēnas bloķēšana neietekmē atmiņas iedalīšanu parējās arēnās un atmiņas iedalīšana var notikt paralēli.
GNU C bibliotēkā darbība ar arēnām notiek saskaņā ar sekojošo algoritmu: 

\begin{enumerate}
\item malloc() izsaukums vēršas pie arēnas, kurai piekļuva iepriekšējo reizi,
\item ja arēna ir nobloķēta, tad malloc() vēršas pie nākamas izveidotās arēnas,
\item ja nav piekļuves nevienai arēnai, tad tiek izveidota jauna arēna un malloc() vēršas pie tās.
\end{enumerate}
Vispirms atmiņas iedalīšana sākas no galvenās arēnas (main arena). 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.50]{threads}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {Arēnas GNU C bibliotēkā }}}
\end{figure}

GNU C bibliotēkā ir globāls \texttt{malloc\_state} objekts - globāla arēna, kura atšķiras ar to, kā atmiņu no kodola iegūst, izmantojot brk() (sk. 2.6. attēlu) \cite{AMM}. 
Pārējas arēnas šīm nolūkam izmanto \texttt{mmap()} izsaukumu. 
Ja kārtēja kaudze ir izlietota, tad tiek iedalīta jauna kaudze ar fiksēto 64 MB izmēru.
Tāda veidā arēnas var tikt paplašinātas, pievienojot jaunās kaudzes un savienojot tās sava starpā.
Lai nodrošinātu labāku veiktspēju, tiek izmantots modelis: katram pavedienam - viena arēna. 
Ja malloc() pirmo reizi izsaukts pavedienā, tad neatkarībā no tā vai arēna bija nobloķēta vai nē, tiks izveidota jauna arēna.
Arēnu skaits ir ierobežots atkarībā no kodolu skaita, 32 bitu vai 64 bitu arhitektūras un mainīga MALLOC\_ARENA\_MAX vērtības.
Tā kā pavedienu skaits parasti nepārsniedz divkāršo kodolu skaitu, tad normālā gadījumā katrs pavediens izmanto atsevišķo arēnu. 



