
\section{Atmiņas noplūde}
 


\textbf{1. hipotēze:} Pēc norādēm procesa adrešu telpā ir iespējams noteikt vai atmiņas izmetē ir novērojama atmiņās noplūde.

Atmiņas noplūdes pazīmes ir pētītas, izmantojot sagatavoto atmiņas izmeti, kas uzģenerēta ar programmas palīdzību (sk. 1. pielikumu).
Programmai no komandrindas tika padoti divi argumenti, ar vērtībām 100, 100.
Pirmais arguments noteic cik daudz gabalu nepieciešams iedalīt, otrais - kāds ir katra gabala izmērs (kilobaitos).
Dotajā programmā atmiņa dinamiski ir iedalīta vairākas reizes. 
Sākumā atmiņa ir iedalīta masīvam arr[ ], kurā ir uzglabātas norādes, pēc tam katram masīva elementam ir iedalīts atmiņas gabals norādītajā izmērā.
Uz brīdī, kad ir izsaukta abort() funkcija, ir jābūt norādei uz arr[ ] masīvu no procesa adrešu telpas.
Turklāt 10 000 kilobaiti ir pazaudēti, jo  katram elementam masīvā, tika piešķirta NULL vērtība. 
Tā kā masīvs arr[ ] bija dinamiski iedalīts, tad norādes uz 100 gabaliem ir jāmeklē kaudzē.
\begin{enumerate}
\item Ir jāpārliecinās, ka ir norāde uz arr[ ] masīvu no procesa adrešu telpas;
\item Ir jāpaliecinās, ka kaudzē nav norāžu ne uz vienu no 100 iedalītiem gabaliem;
\end{enumerate}

Sākumā, lai pārliecinātos par abiem gadījumiem ir nepieciešams iegūt kaudzes saturu.
Tā kā programmai ir tikai viens pavediens, tad dinamiski iedalītā atmiņa atrodas galvenajā kaudzē.
Lai piekļūtu galvenai kaudzei, ir nepieciešams, izmantot komandu \texttt{p main\_arena}, lai iegūtu top elementu, kas dotajā gadījumā norāda uz 0x90034b8 adresi (sk. 3.1. attēlu). 
Pēc šīs adreses ir uzglabāts top gabals, kurš ierobežo kaudzes segmentu.
Galvenās kaudzes saturs būs uzreiz pirms top rādītāja, tas nozīme, ka kaudzes adreses būs mazākas.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) p main_arena
$1 = {mutex = 0, flags = 1, fastbinsY = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, top = 0x90034b8, last_remainder = 0x0, 
  bins = {0xb76c4470, 0xb76c4470, 0xb76c4478, 0xb76c4478, 0xb76c4480, 0xb76c4480, 0xb76c4488, 0xb76c4488, 0xb76c44908...}, 
  binmap = {0, 0, 0, 0}, next = 0xb76c4440, next_free = 0x0, system_mem = 10375168, max_system_mem = 10375168}
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Galvenā arēna}}}
\end{figure}
Zinot top gabala adresi, kaudzes izmēru no max\_system\_mem elementa un atņemot top gabala izmēru (neizmantotā atmiņa) var iegūt kaudzes sākumu.
Ir jāņem vērā, ka mazākie biti netiek izmantoti izmēra glabāšanai, bet kontroles zīmēm.
Turpmāk ir iegūts kaudzes saturs un pirmais kaudzes gabals (sk. 3.2. attēlu).
Šajā gabalā ir uzglabāts arr[ ] masīvs. To var atpazīt pēc atmiņās gabala lieluma, kurš dotajā gadījumā ir vienāds ar 409 (4 baiti - katra norāde, kopumā masīvā ir 100 norādes).
Pēc tam, kad ir izdrukāts gabals, ir iespējams iegūt adresi, kuru atgrieza malloc() funkcija programmai.
Dotajā gadījumā šī adrese būs vienāda ar 0x863f000+8 = 0x863f008.
Pirmajos 8 baitos ir uzglabāta uzturēšanas informācija.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) x/16wd 0x90034b8-10375168+133960
0x863f000:	0	409	0	140870056
0x863f010:	0	141074872	0	141279688
0x863f020:	0	141484504	0	141689320
0x863f030:	0	141894136	0	142098952
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Pirmais gabals kaudzē}}}
\end{figure}
Nākamais solis ir sameklēt norādi uz šo adresi no procesa adrešu telpas.
Tā kā uz arr[ ] masīvu norāda lokāla norāde main() funkcijā, tad dotā adrese ir jāmeklē stekā.
Izdrukājot steku ir iegūta norāde uz arr[ ] masīvu (sk. 3.3. attēlu).
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) x/80wx $esp+336
0xbf853d34:	0x00002710	0x00019000	0x00002710	0xffffffff
0xbf853d44:	0xb7551196	0x00000064	0x00000064	0x00000064
0xbf853d54:	0x00000064	0x00000064	0x0863f008	0x08048690
0xbf853d64:	0xb76c3ff4	0x00000000	0xb75374d3	0x00000003
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Steka satura iztrūka}}}
\end{figure}

Lai pārbaudītu otro gadījumu, kad norāžu nav, žurnālā (log datnē) tika izdrukāts pilns kaudzes saturs un tika meklēti pazaudētie gabali.
Kaudzē nebija nevienas norādes uz nevienu pazaudēto gabalu, tātad 1. hipotēze ir apstiprināta.

\textbf{1. pazīme:}  Par fiziskās atmiņas noplūdes pazīmi var uzskatīt stāvokli, kad uz atmiņas gabaliem kaudzē nav norāžu no procesa adrešu telpas.
Par šo programmas stāvokli var pārliecināties, veicot atmiņas izmetes analīzi.
Interpretējot kaudzes saturu, kā kopu ar daudziem atmiņas gabaliem, var iegūt adreses, uz kuriem malloc() funkcija atgrieza norādes procesam.
Ja procesa adrešu telpā nav nevienas norādes uz atrastajām adresēm, tad var apgalvot, ka programmā ir pazaudētie gabali, kuri izraisa atmiņas noplūdi.


%\textbf{2. hipotēze:} Pazaudēts atmiņas kopējais izmērs ietekmē kaudzes un atmiņas izmetes izmēru.
\section{Maksimālās atmiņas izmantošanas problēma}


\textbf{1. hipotēze:} Maksimālā atmiņas izmantošanas problēma ietekmē bin sarakstus.

\textbf{2. hipotēze:} Atbrīvoti un iedalītie gabali nav vienmērīgi sadalīti kaudzē.

Maksimālās atmiņas izmantošanas problēmas pazīmes ir pētītas, izmantojot sagatavoto atmiņas izmeti, kas uzģenerēta ar programmas palīdzību (sk. 2. pielikumu).

\section{Fragmentēšana}


\textbf{1. hipotēze:} Fragmentēšana ietekmē ātro sarakstu un parasto sarakstu.

Fragmentēšanas problēmas pazīmes ir pētītas, izmantojot sagatavoto atmiņas izmeti, kas uzģenerēta ar programmas palīdzību (sk. 3. pielikumu).







\section{Maksimālās atmiņas izmantošanas problēma}



Turpmāk tiks apskatīts piemērs, kurš demonstrē doka izpaužas dotā problēmā.
Lai kontrolētu atmiņas patēriņu, procesa izpildes laikā, tika izmantota \texttt{ps} komanda.
Procesam patērēts atmiņas daudzums iegūts no RSS un VSZ rādītājiem.
VSZ parāda virtuālo atmiņu, RSS parāda fizisko atmiņu, kuru izmanto process.
Rādītāju mērvienība ir kilobaits.
Tika palaista programma un katrā programmas solī tika noņemti radītāji (sk. 3.1. tabulu).
Tā kā bija iedalīti 100 gabali, katrs 100 kilobaitu izmērā, tad kaudze bija paplašināta ar brk() sistēmas izsaukumu.
Kopēja pieprasīta atmiņa bija vienāda ar 10000 kilobaitiem.
Iegūtie rādītāji parāda, ka atmiņa pilnībā tika atbrīvota tikai pēc tam, kad bija atbrīvots pēdējais atmiņas gabals.
To var redzēt 4 solī, kur VSZ un RSS rādītāji paliek nemainīgi, salīdzinot ar iepriekšējo soli.
Turklāt 5 solī, pēc pēdējā gabala atbrīvošanas, var novērot to, ka atmiņās daudzums samazinās, tas ir izskaidrojams ar to, ka atmiņa tika atgriezta operētājsistēmai.


\begin{table}[H]
\caption{\textbf{\fontsize{11}{12}\selectfont {Programmas RSS un VSZ radītāji}}}
\label{table:kysymys}
\centering
	\begin{tabular}{|l|l|l|p{5cm}|}
	  \hline
	Solis & VSZ & RSS \\
    \hline
    1. Sākums & 3228 & 612 \\
	\hline
	 2. Ar new ir pieprasīti 100 gabali, katrs 100 kilobaitu izmērā  & 13360  & 1136 \\
      \hline
     3. Atmiņa ir aizpildīta ar 0 &  13360 & 10640\\
      \hline
     4. Atmiņa tiek atbrīvota izņemot pēdejo gabalu & 13360 & 10640 \\
      \hline
     5. Atmiņa tiek pilnībā atbrīvota & 3360 & 968 \\
    \hline
	\end{tabular}
\end{table}

\subsection{Maksimālās atmiņas izmantošanas problēmas pazīmes}



Atmiņas izmetē pazīme, kas varētu liecināt par problēmu, ir lielā izmēra atmiņas gabali, kuri atrodas bin sarakstos.
Ja pēc maksimālās atmiņas izmantošanas bija novērojamā fragmentēšana, tad bin sarakstos varētu atrasties liels atmiņas gabalu skaits.
Tāds skaits, kurš varētu tikt izveidots sadalot mazākos gabalos procesa atmiņas patēriņa pieaugumu, kas notika mēģinot sasniegt maksimumu.
Saskaņā ar GNU C realizāciju visi atbrīvotie gabali tiek uzglabāti bin sarakstos.
Tā kā ātrie saraksti uzglabā mazus atmiņas gabalus (līdz 64 baitiem) un nav paredzēti ilgstošai atmiņas gabalu glabāšanai, tad atmiņas gabali tiks uzglabāti parastajos sarakstos.

Tālāk ir aprakstīts piemērs, kurš parāda, ka problēmas pazīme izpaužas atmiņas izmetē.
Sākumā tika iedalīti 100 atmiņas gabali, katrs 100 kilobaitu izmēra.
Katrā baitā bija ierakstīta vērtība 7.
Pēc tam bija atbrīvoti 99 gabali izņemot pēdējo.
Beigās, lai apskatīties pazīmi, tika uzģenerēta atmiņas izmete.
Saskaņā ar pētījumā minētām shēmām \cite{PWMS}  bija sasniegts maksimums (peaks).
Atmiņas izmete palīdz saprast, kas notiek atmiņā.
\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
(gdb) p main_arena
$3 = {mutex = 0, flags = 1, fastbinsY = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, top = 0x97ba4b8, last_remainder = 0x0,
bins = {0x8df6198, 0x8df6198, 0xb76cf478, 0xb76cf478, 0xb76cf480, 0xb76cf480, 0xb76cf488, 0xb76cf488, 0xb76cf490, 0xb76cf490,
0xb76cf498, 0xb76cf498, 0xb76cf4a0, 0xb76cf4a0, 0xb76cf4a8, 0xb76cf4a8, 0xb76cf4b0, 0xb76cf4b0, 0xb76cf4b8, 0xb76cf4b8,
0xb76cf4c0, 0xb76cf4c0, 0xb76cf4c8, 0xb76cf4c8, 0xb76cf4d0, 0xb76cf4d0, 0xb76cf4d8, 0xb76cf4d8, 0xb76cf4e0, 0xb76cf4e0...},
binmap = {0, 0, 0, 0}, next = 0xb76cf440, next_free = 0x0, system_mem = 10375168, max_system_mem = 10375168}
(gdb) x/16wx 0x8df6198
0x8df6198: 0x00000000 0x009ab319 0xb76cf470 0xb76cf470
0x8df61a8: 0x00000000 0x00000000 0x07070707 0x07070707
0x8df61b8: 0x07070707 0x07070707 0x07070707 0x07070707
0x8df61c8: 0x07070707 0x07070707 0x07070707 0x07070707
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {bin saraksta izdruka, izmantojot atmiņas izmeti}}}
\end{figure}
%$
Ar \texttt{p main\_arena} ir izdrukāta galvenās arēnas struktūra un iegūtas bin sarakstu sākuma adreses (sk. 3.3. attēlu).
Visi bin saraksti atrodas masīvā bins.
7 rindiņā ir komanda, kura izdrukā 16 adreses no pirmā nesakārtotā bin saraksta, kurā atrodas gabali, kuri bija nesen atbrīvoti.
Sākot ar 8 rindiņu ir redzams atmiņas gabals, kas atrodas bin sarakstā un kura izmērs ir 0x009ab319, kas decimālajā skaitīšanas sistēmā ir vienāds ar 10138393, binārajā skaitīšanas sistēmā 100110101011001100011001.
Tā kā 3 mazākie biti netiek izmantoti izmēra glabāšanai, tad gabala izmērs ir 10138393 - 1=10138392.
Mūsu 99 atbrīvoto gabalu kopējais izmērs ir vienāds ar izmēru kilobaitos, kas ir sareizināts ar atbrīvoto gabalu skaitu, tātad 100*1024*99 = 10137600.
Atšķirība starp pirmā gabala izmēru bin sarakstā un atbrīvoto gabalu kopēju izmēru ir vienāda ar 10138392 - 10137600 = 792 un izskaidrojama ar to, ka katram gabalam bija iedalīti 8 baiti uzturēšanas informācijas glabāšanai (prev\_size, size).
Pārējie 127 bin un ātrie bin saraksti, dotajā piemērā, bija tukši.

\section{Fragmentēšana}





\subsection{Fragmentēšanas pazīmes}
Iekšējai fragmentēšanai nav pazīmju atmiņas izmetē, kuras varētu liecināt par doto problēmu.
Lai atpazītu doto problēmu ir nepieciešams zināt cik daudz atmiņas pieprasīja lietotne.
Izmantojot tikai atmiņas izmeti šo informāciju iegūt nevar.

No problēmas apraksta seko, ka ārējai fragmentēšanai ir raksturīgs liels mazo\footnote{Mazs nozīme tāds, kurš nevar apmierināt turpmākos pieprasījumus pēc atmiņas.} atbrīvoto gabalu skaits.
Šie gabali var būt saglabāti vienā no bin sarakstiem:
\begin{itemize}
\item Ja izmērs ir līdz 64 baitiem, nav veikta ātra saraksta saplūdināšana vai mazie gabali nevar tikt saplūdināti, tad atbrīvotie gabali tiks novietoti ātrajos sarakstos.
Ātrajos sarakstos gabals norādīs uz nākamo gabalu un veidos garo sarakstu no visiem atmiņas gabaliem;
\item Ja ātrie gabali tika saplūdināti vai gabali ir lielāki par 64 baitiem, tad tie tiks novietoti parastajos sarakstos.
\end{itemize}

Kaudze būs saskaldīta un katrs iedalītais gabals robežos ar mazāko atbrīvoto gabalu.
Piemēra ir izdrukāts kaudzes saturs (sk. 3.5. attēlu).
Kaudzē atrodas iedalītie gabali 32 baitu (0x21) izmērā un atbrīvotie gabali 16 baitu (0x11) izmērā.
Atbrīvotie gabali ir saistīti sava starpā un atrodās ātrajā sarakstā.
Tas ir novērojams, jo lietotāju datos ātrajiem gabaliem ir uzglabāta nākama gabala adrese.
Pēdejām gabalam ātrajā sarakstā ir uzglabāta 0x00000000 adrese.
Dotajam piemēram fragmentēšana ir vienāda ar 50\%.

\begin{figure}[h]
\begin{lstlisting}[style=customgdb]
0x8b30198: 0x00000000 0x00000011 0x00000000 0x00000000
0x8b301a8: 0x00000000 0x00000021 0x00000000 0x00000000
0x8b301b8: 0x00000000 0x00000000 0x00000000 0x00000000
0x8b301c8: 0x00000000 0x00000011 0x08b30198 0x00000000
0x8b301d8: 0x00000000 0x00000021 0x00000000 0x00000000
0x8b301e8: 0x00000000 0x00000000 0x00000000 0x00000000
0x8b301f8: 0x00000000 0x00000011 0x08b301c8 0x00000000
0x8b30208: 0x00000000 0x00000021 0x00000000 0x00000000
0x8b30218: 0x00000000 0x00000000 0x00000000 0x00000000
0x8b30228: 0x00000000 0x00000011 0x08b301f8 0x00000000
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Fragmentētā kaudze}}}
\end{figure}




\section{Problēmas glibc bibliotēkā}
\subsection{glibc problēmu pazīmes}
