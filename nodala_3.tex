\section{Atmiņas noplūde}


Atmiņas noplūde ir viena no bieži sastopamām problēmām \cite{atparv}.
Atmiņas noplūde notiek nepareizās lietotāja atmiņas pārvaldības dēļ, kad atmiņa, kura vairs netiks izmantota programmā, netiek atbrīvota.
Atmiņas noplūdes problēmu var sadalīt divos dažādos veidos.
Pirmkārt, šī problēma ir novērojama, kad procesam iedalītās atmiņas adreses kļūst nepieejamas, pazaudētas.
Atmiņa var kļūt nepieejama gadījumos, kad procesa adrešu telpā uz iedalīto atmiņas gabalu kaudzē nenorāda neviens rādītājs.
Otrs problēmas veids ir novērojams, kad iekšējā buferī, rindā vai cita datu struktūrā dinamiski iedalītu elementu skaits pieaug neierobežoti.
Tas atšķiras no pirmā veida ar to, ka visi elementi joprojām ir pieejami un procesa adrešu telpā ir rādītājs uz dinamiski iedalītu elementu.
Abos gadījumos dinamiskā atmiņas iedalīšana programmai turpināsies līdz brīdim, kad  tiks sasniegts RLIMIT limits.
Šos limitus var atrast \texttt{man setrlimit} komandas izvadā. 
Limitiem, aprakstā ir nodarīts, kas ir jādara, kad limits ir pārsniegts.
Daži no limitiem šajā gadījumā nosūta signālus procesiem, kuri izraisa atmiņas izmetes ģenerēšanu.
\begin{figure}[h]
\begin{lstlisting}
#include <string>
using namespace std;

int main() {
    string *str;

    for (int i=0; i<10001; i++) {
        // 10000*14 bytes are lost
        str = new string("Hello, World!");
    }
    delete str;

    return 0;
}
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas noplūde, C++}}}
\end{figure}

Atmiņās noplūdes problēma ir uzskatāmi nodemonstrēta piemērā (sk. 3.1. attēlu).
Programma  iedala 10001 atmiņas gabalus ar new operatora palīdzību. 
Rādītājs \texttt{str} katru reizi tiek pārrakstīts un norāda uz kārtējo iedalīto atmiņas gabalu.
Beigās tiek atbrīvots tikai viens atmiņas gabals, kurš bija iedalīts pēdējais. 
Programmas darbības laikā kļūst pazaudēti 10000 gabali, kuru kopējais izmērs ir 140000 baiti.
 


Sekojošos gadījumos sistēmas kļūst viegli ievainojamas, ja tajās ir kļūda, kas izraisa atmiņās noplūdi \cite{RTTV}: 
\begin{itemize}
\item { Operētājsistēma neatbrīvo, lietotnes izpildei izmantoto atmiņu, kad lietotne beidz savu darbību, piemēram, AmigaOS,}
\item { Ja servera vai citas programmas darbojās visu laiku bez apstājas, }
\item { Ja iegultās sistēmas strādā gadiem ilgi, }
\item { Ja portatīvām ierīcēm ir ierobežots atmiņas daudzums, }
\item { Ja programmas pieprasa atmiņu uzdevumiem, kuri izpildās ilgstošu laika periodu, }
\item { Reālā laikā sistēmām, jo ir svarīgi iegūt rezultātu ierobežotajā laikā. }
\end{itemize}

Atmiņas noplūdes problēmu ir grūti atkļūdot,  jo nav zināmi nosacījumi, kuriem izpildoties notiek atmiņas noplūde. 
Ja pazaudētās atmiņas daudzums nav liels, tad izstrādātājiem ir grūti atklāt un izlabot atmiņas noplūdi. 
Eksistē vairāki rīki, kuri palīdz atkļūdot atmiņas noplūdes problēmu, tādi ka: Valgrind, Totalview, Purify.
\subsection{Atmiņas noplūdes sekas}





\subsection{Atmiņas noplūdes pazīmes}

Rakstā \cite{RHBJ} ir minēts, ka atmiņas noplūdes problēmu ir grūti atkļūdot, jo tai nav tiešas pazīmes, kas ļauj ātri identificēt problēmu.
Tā kā atmiņas noplūdes laikā atmiņa tiek pazaudēta, tad var periodiski novērot procesa atmiņas patēriņa pieaugumu, kura dēļ, daļa no informācijas tiks uzglabāta lapošanas failā (paging file).
Pēc tam notiks pakāpeniskā procesa palēnināšana, jo procesa izpildei pietrūks brīvpiekļuves atmiņas un virtuālās atmiņas.

 un atmiņas patēriņa pieaugums. 




\section{Atmiņas nevienmērīga lietošana}
\subsection{Atmiņas nevienmērīga lietošanas sekas}
\subsection{Atmiņas nevienmērīga lietošanas pazīmes}

\section{Fragmentēšana}
\subsection{Fragmentēšanas sekas}
\subsection{Fragmentēšanas pazīmes}

\section{Kļūdas glibc bibliotēkā}
\subsection{glibc kļūdu sekas}
\subsection{glibc kļūdu pazīmes}
