\section{Atmiņas noplūde}


Atmiņas noplūde ir viena no bieži sastopamām problēmām \cite{atparv}.
Atmiņas noplūde notiek nepareizās lietotāja atmiņas pārvaldības dēļ, kad atmiņa, kura vairs netiks izmantota programmā,  nekad netiek atbrīvota, ka arī netiek atgriezta operētājsistēmai. 
Tā kā atmiņa, kas varētu tikt iedalīta dinamiski, ir ierobežots resurss, tad atmiņas adrešu iedalīšana programmai turpināsies līdz brīdim, kad  brīvpiekļuves atmiņas (RAM) un virtuālās atmiņas resursi tiks izsmelti un neviens pieprasījums pēc atmiņas netiks izpildīts.


Atmiņās noplūdes problēma ir uzskatāmi nodemonstrēta piemērā (sk. 3.1. attēlu).
Programma  iedala 10001 atmiņas gabalus ar new operatora palīdzību. 
Rādītājs \texttt{str} katru reizi tiek pārrakstīts un norāda uz kārtējo iedalīto atmiņas gabalu.
Beigās tiek atbrīvots tikai viens atmiņas gabals, kurš bija iedalīts pēdējais. 
Programmas darbības laikā kļūst pazaudēti 10000 gabali, kuru kopējais izmērs ir 140000 baiti.
 
\begin{figure}[h]
\begin{lstlisting}
#include <string>
using namespace std;

int main() {
    string *str;

    for (int i=0; i<10001; i++) {
        // 10000*14 bytes are lost
        str = new string("Hello, World!");
    }
    delete str;

    return 0;
}
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas noplūde, C++}}}
\end{figure}

Sekojošos gadījumos sistēmas kļūst viegli ievainojamas, ja tajās ir kļūda, kas izraisa atmiņās noplūdi \cite{RTTV}: 
\begin{itemize}
\item { Operētājsistēma neatbrīvo, lietotnes izpildei izmantoto atmiņu, kad lietotne beidz savu darbību, piemēram, AmigaOS,}
\item { Ja servera vai citas programmas darbojās visu laiku bez apstājas, }
\item { Ja iegultās sistēmas strādā gadiem ilgi, }
\item { Ja portatīvām ierīcēm ir ierobežots atmiņas daudzums, }
\item { Ja programmas pieprasa atmiņu uzdevumiem, kuri izpildās ilgstošu laika periodu, }
\item { Reālā laikā sistēmām, jo ir svarīgi iegūt rezultātu ierobežotajā laikā. }
\end{itemize}

Atmiņas noplūdes problēmu ir grūti atkļūdot,  jo nav zināmi nosacījumi, kuriem izpildoties notiek atmiņas noplūde. 
Ja pazaudētas atmiņas daudzums nav liels, tad izstrādātājiem ir grūti atklāt un izlabot atmiņas noplūdi. 
Eksistē vairāki rīki, kuri palīdz atkļūdot atmiņas noplūdes problēmu, tādi ka: Valgrind, Totalview, Purify.
\subsection{Atmiņas noplūdes sekas}





\subsection{Atmiņas noplūdes pazīmes}

Rakstā \cite{RHBJ} ir minēts, ka atmiņas noplūdes problēmu ir grūti atkļūdot, jo tai nav tiešas pazīmes, kas ļauj ātri identificēt problēmu.
Tā kā atmiņas noplūdes laikā atmiņa tiek pazaudēta, tad var periodiski novērot procesa atmiņas patēriņa pieaugumu, kura dēļ, daļa no informācijas tiks uzglabāta lapošanas failā (paging file).
Pēc tam notiks pakāpeniskā procesa palēnināšana, jo procesa izpildei pietrūks brīvpiekļuves atmiņas un virtuālās atmiņas.

 un atmiņas patēriņa pieaugums. 




\section{Atmiņas nevienmērīga lietošana}
\subsection{Atmiņas nevienmērīga lietošanas sekas}
\subsection{Atmiņas nevienmērīga lietošanas pazīmes}

\section{Fragmentēšana}
\subsection{Fragmentēšanas sekas}
\subsection{Fragmentēšanas pazīmes}

\section{Kļūdas glibc bibliotēkā}
\subsection{glibc kļūdu sekas}
\subsection{glibc kļūdu pazīmes}
