\section{Atmiņas noplūde}


Atmiņas noplūde (memory leak) ir viena no bieži sastopamām problēmām C un C++ valodās \cite{atparv}.
Atmiņas noplūde notiek nepareizās lietotāja atmiņas pārvaldības dēļ, kad atmiņa, kura vairs netiks izmantota programmā, netiek atbrīvota.

Atmiņas noplūdes problēmu var sadalīt divos dažādos veidos: fiziskā un loģiskā atmiņas noplūde \cite{JMMR}.
Fiziskā atmiņas noplūde ir novērojama, kad atmiņas adreses, kuras tika iedalītas procesam,  kļūst nepieejamas, pazaudētas, tas notiek, kad procesa adrešu telpā uz iedalīto atmiņas gabalu kaudzē nenorāda neviens rādītājs.
Šīs programmas stāvoklis var būt novērojams 3 iemeslu dēļ \cite{JMMR}:
\begin{itemize}
\item pēdēja norāde uz atmiņas gabalu ir pārrakstīta vai norāde bija palielināta, piemēram, lai sasniegtu datus ar nobīdi,
\item norāde atrodas ārpus darbības lauka (out of scope),
\item atmiņas bloks, kurš glabāja norādi, bija atbrīvots.
\end{itemize}

Loģiskā atmiņas noplūde ir novērojama, kad iekšējā buferī, rindā vai citā datu struktūrā ir uzglabātas norādes uz dinamiski iedalītu atmiņu, bet norāžu skaits pieaug neierobežoti.
Loģiskā atmiņas noplūdi bieži nosauc par slēpto atmiņas noplūdi (hidden memory leak) \cite{RRUU}, jo atmiņa ir joprojām sasniedzama no programmas, bet nekad netiek atbrīvota.

Abos gadījumos sekas ir vienādas.
Sākumā tiks novērota pakāpeniskā procesa palēnināšana, jo daļa no informācijas tiks uzglabāta lapošanas failā (paging file).
Kaut kāda brīdī, kad tiks iztērēta visā dinamiskā atmiņa, katrs malloc() funkcijas izsaukums būs neveiksmīgs.
Šeit var notikt kritiskā kļūda, kuras cēlonis ir sliktā programmēšanas prakse.
Programmētāji ne vienmēr pārbauda malloc() rezultātu pirms vērsties pēc malloc() funkcijas atgrieztās norādes.  
Mēģinājums piekļūt null adresei  izraisīs Segmentation fault kļūdu.
Ja programmā bija paredzēts, ka malloc() var atgriezt null, tad process turpinas izpildi ierobežotā režīmā, jo vairs nav iespējams dinamiski iedalīt atmiņu. 
Daudzās sistēmās tas nav pieļaujams un var tikt uzstādīti dažādi ierobežojumi, kuri pēc ierobežojošās vērtības sasniegšanas (izpildes laiks, patērētās atmiņas) automātiski pārtrauks procesa darbību. 

\begin{figure}[h]
\begin{lstlisting}
#include <string>
using namespace std;

int main() {
    string *str;

    for (int i=0; i<10001; i++) {
        // 10000*14 bytes are lost
        str = new string("Hello, World!");
    }
    delete str;

    return 0;
}
\end{lstlisting}
\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas noplūde, C++}}}
\end{figure}

Atmiņās noplūdes problēma ir uzskatāmi nodemonstrēta piemērā (sk. 3.1. attēlu).
Programma  iedala 10001 atmiņas gabalus ar new operatora palīdzību. 
Rādītājs \texttt{str} katru reizi tiek pārrakstīts un norāda uz kārtējo iedalīto atmiņas gabalu, kurā izmērs ir 14 baiti.
Tā kā atmiņas adreses kļūst pazaudētas un nav iespējas piekļūt iepriekšējiem elementiem pēc tam kad  \texttt{str} radītājs ir parakstīts, tad piemēra ir redzama fiziskā atmiņas noplūde.
Beigās tiek atbrīvots tikai viens atmiņas gabals, kurš bija iedalīts pēdējais. 
Programmas darbības laikā kļūst pazaudēti 10000 gabali, kuru kopējais izmērs ir 140000 baiti.
 Pēc programmas izpildes beigām visā procesam iedalītā atmiņa tiek atgriezta operētājsistēmai.


Sekojošos gadījumos sistēmas kļūst viegli ievainojamas, ja tajās ir kļūda, kas izraisa atmiņās noplūdi \cite{RTTV}: 
\begin{itemize}
\item { Kad operētājsistēma neatbrīvo, lietotnes izpildei izmantoto atmiņu pēc tam, kad lietotne beidz savu darbību, piemēram, AmigaOS,}
\item { Ja servera vai citas programmas darbojās visu laiku bez apstāšanās, }
\item { Ja portatīvām ierīcēm ir ierobežots atmiņas daudzums, }
\item { Ja programmas pieprasa atmiņu uzdevumiem, kuri izpildās ilgstošu laika periodu, }
\item { Reālā laikā sistēmās, jo ir svarīgi iegūt rezultātu ierobežotajā laikā. }
\end{itemize}

Atmiņas noplūdes problēmu ir grūti atkļūdot,  jo nav zināmi nosacījumi, kuriem izpildoties notiek atmiņas noplūde. 
Ja ir redzamas sekas (ir atmiņas izmete un programma pabeidza savu darbu), bet nav zināms problēmas cēlonis, tad izstrādātājiem ir nepieciešams daudz resursu, lai atkārtotu un izlabotu atmiņas noplūdi. 
Eksistē vairāki rīki, kuri palīdz atkļūdot atmiņas noplūdes problēmu, tādi ka: Valgrind, Totalview, Purify. 
Taču tie ne vienmēr sniedz pietiekamu informāciju un bieži netiek izmantoti strādājošās sistēmās, jo piedāvātas atkļūdošanas tehnikas un rīki var palēnināt sistēmas darbību.
Ieslēdzot  Memcheck rīku iekš Valgrind instrumentācijas ietvarā, programmas izpildes ātrums palēninās 20-30 reizes \cite{UVD}.



\subsection{Atmiņas noplūdes pazīmes}

Reālajās sistēmās problēma var izpausties uzreiz pēc palaišanas, bet var kļūt novērojama tikai pēc dažiem gadiem. 
Abi gadījumi ir izplatīti \cite{HTTM}.
Tā kā atmiņas noplūdes rezultātā atmiņa tiek pazaudēta, tad var periodiski novērot procesa atmiņas patēriņa pieaugumu.
Pazīme, kas varētu liecināt par atmiņas noplūdi ir pārmērīgs\footnote{Šajā kontekstā pārmērīgs nozīme, ka izmērs ir lielāks par to, kuru paredz programmētājs un tas rāda pamatotas šaubas, par atmiņas noplūdes problēmas esamību programmā.}
atmiņas daudzums, kas visu laiku pieaug. 
Kad process izmanto pārmērīgo atmiņu un izmantotās atmiņas daudzums nemainās, tad šī pazīme var dot tikai aptuvenu novērtējumu par dotās problēmas esamību, jo eksistē vairākas citas problēmas, piemēram, fragmentēšana, maksimālā kopējā kaudzes izlietošana vai kļūdas trešās puses bibliotēkās, kuras var palielināt izmantotās atmiņas daudzumu.
Tā kā atmiņas izmete satur procesa atmiņas attēlojumu uz procesa pārtraukšanas brīdi, tad uzģenerētās datnes izmērs, atmiņas noplūdes problēmas ietekmēs rezultātā, var sasniegt vairākus gigabaitus.


Par fiziskās atmiņas noplūdes pazīmi var uzskatīt stāvokli, kad uz atmiņas gabaliem kaudzē nav norāžu no procesa adrešu telpas.
Par šo programmas stāvokli var pārliecināties, veicot atmiņas izmetes analīzi. 
Atmiņas izmetē atrodas kaudzes saturs visām atmiņas arēnām. 
Interpretējot katru kaudzes saturu, kā kopu ar daudziem atmiņas gabaliem, var iegūt adreses, uz kuriem malloc() funkcija atgrieza norādes procesam.
Ja procesa adrešu telpā nav nevienas norādes uz atrastajām adresēm, tad ar lielu varbūtību var apgalvot, ka programmā ir atmiņas noplūde.
Kamēr kļūda nav atrasta kodā, to nevar secināt, jo atmiņas izmete var būt bojāta un var neiekļaut daļu no procesa adrešu telpas.
Šī pazīme nav raksturīga loģiskajai atmiņas noplūdei.



Loģiskās atmiņas noplūde rezultātā visiem atmiņas gabaliem atbilst norādes procesa adrešu telpā. 
Problēmai ir raksturīgs stāvoklis, kad ir daudzi atmiņas gabali, kuru lietotāja datu sekcija satur līdzīgus datus (izmēru, līdzīgas datu shēmas).
Turpmāk tiks apskatīts piemērs, kurš paskaidro kā var izpausties šī pazīme.
Piemērā ir aplūkots gadījums, kad programmā ir izmantoti objekti, kuri ir  C++ klases instances un klasē ir izmantota virtuālā funkcija.
Ja C++ klasē ir virtuālās funkcijas, tad kompilators izveido virtuālo funkciju tabulu (vtable), kura iekļauj rādītājus uz šī klases virtuālām funkcijām.
 Katrai klasei ir tikai viena virtuālo funkciju tabula, kuru izmanto visi klases objekti.
 Ar katru virtuālo funkciju tabulu ir saistīts virtuālo funkciju rādītājs (vpointer).
 Šīs rādītājs norāda uz virtuālo funkciju tabulu un tiek izmantots lai piekļūtu virtuālajām funkcijām.
Atmiņā klases izvietojums, kurā ir virtuālā funkcija atmiņā tiek attēlots sekojoši (sk. 3.2. attēlu).
Ja loģiskā atmiņas noplūde notiks, tāpēc ka atmiņā neierobežoti pieaugs MyClass objektu skaits, tad pēc vpointer norādes atmiņas gabalos var identificēt doto problēmu, bet saprast kurai klasei pieder objekti var ar gdb palīdzību.
Instrukcijas, kas ļauj apskatīties, kuram apgabalam pieder adrese jau tika aprakstītas sadaļā \ref{subsec:debugg_gdb}
\begin{figure}[h]
\begin{lstlisting}
class MyClass
{
    virtual SomeVirtualMethod();
    
    public:
        void* attribute1;
        void* attribute2;
}
\end{lstlisting}
%\caption{\textbf{\fontsize{11}{12}\selectfont {Atmiņas noplūde, C++}}}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{memoryleak}
\end{center}
\caption{\textbf{\fontsize{11}{12}\selectfont {C++ klases ar virtuālo funkciju izvietojums atmiņā }}}
\label{fig:memoryleak}
\end{figure}



\section{Maksimālā kopējā kaudzes izlietošana}
 \label{sec:peak_mem}
Atmiņas daudzums, kas tiek izmantots programmas izpildes laikā var visu laiku mainīties.
Pētījumā \cite{PWMS} tiek apkopoti trīs svarīgākie nevienmērīgās atmiņas izmantošanas veidi: traps (ramps),  maksimums (peaks),  plankalne (plateaus).
Citi nevienmērīgās izmantošanas veidi arī ir iespējami, bet izpaužas ļoti reti.
Ne visām programmām raksturīgi visi trīs veidi, bet tikai daži no tiem.
Šie veidi ir kvantitatīvs novērtējums, kas tiek novērojams izpētot lielu programmu kopu \cite{PWMS}. 
\begin{itemize}
\item Traps. Programma uzkrāj datu struktūras monotoni. 
Tas varētu notikt, tāpēc ka uzdevuma atrisināšanai ir nepieciešams paveikt daudzas darbības un pakāpeniski uzbūvēt daudzas  datu struktūras. 
Lai atrisinātu uzdevumu, atmiņas patēriņš monotoni aug. Pēc uzdevuma atrisināšanas atmiņas patēriņš strauji samazinās.
\item Maksimums. Šo veidu var nosaukt par trapu tikai ļoti īsa laika periodā.
Daudzām programmām var būt nepieciešams izveidot lielas datu struktūras, kāda ātra uzdevuma izpildīšanai.
Pēc šī uzdevuma pabeigšanas gandrīz visa pieprasītā atmiņa var tikt atbrīvota.
Grafiks šīm veidam izskatās kā raustīta līnija un atmiņas patēriņš var svārstīties dramatiski.
\item Plankalne. Novērojama, kad programmas ātri uzbūve datu struktūras un izmanto tās ilgā laika periodā. Var izmantot līdz programmas izpildes beigām.
\end{itemize}

Ir svarīgi pievērst uzmanību gadījumiem, kad var tikt sasniegta maksimālā kopējā atmiņas izlietošana.
Maksimālā kopējā atmiņas izlietošana ir stāvoklis, kad kopējais iedalītu un atbrīvotu gabalu izmērs kaudzē sasniedz maksimumu.
Piemēram, tas var notikt, kad process tiecās pie trapa virsotnes vai maksimuma sasniegšanas.
Šeit ir iespējama situācija, kad liels atmiņas daudzums pēc izmantošanas netiks atgriezts operētājsistēmai, pat tad, ja atmiņa tiks atbrīvota ar free() vai delete palīdzību.
Rezultātā process var patērēt pārmērīgo atmiņas daudzumu, kurš nebija paredzēts projektējumā.
Šī situācija kļūst iespējama, ja notiek daudzi pieprasījumi pēc atmiņas, kas ir mazāki par 128 kilobaitiem.
Pieprasījums pēc lielākiem atmiņas gabaliem tiks apstrādāts ar mmap() sistēmas izsaukumu un neizraisīs doto problēmu.
Pēc mmap() izsaukumiem atmiņu ir iespējams atgriezt operētājsistēmai ar munmap() palīdzību. 
Bet, izmantojot brk() sistēmas izsaukumu, kamēr netiks atbrīvots atmiņas gabals, kas atrodas beigās, atmiņa netiks atgriezta operētājsistēmai.

Turpmāk tiks apskatīts piemērs, kurš demonstrē doto problēmu.
Lai kontrolētu atmiņas lietojumu, procesa izpildes laikā, tika izmantota \texttt{ps} komanda.
Procesam patērēts atmiņas daudzums iegūts no RSS un VSZ rādītājiem.
VSZ parāda virtuālo atmiņu, RSS parāda fizisko atmiņu, kuru izmanto process.
Rādītāju mērvienība ir kilobaits.
Tika palaista programma un katrā programmas solī tika noņemti radītāji (sk. 3.1. tabulu).
Tā kā bija iedalīti 100 gabali, katrs 100 kilobaitu izmēra, tad kaudze bija paplašināta ar brk() sistēmas izsaukumu.
Kopēja pieprasīta atmiņa bija vienāda ar 10000 kilobaitiem.
Uzņemtie rādītāji parāda, ka atmiņa pilnībā tika atbrīvota tikai pēc tam, kad bija atbrīvots pēdējais atmiņas gabals.
To var redzēt 4 solī, kur VSZ un RSS rādītāji paliek nemainīgi, salīdzinot ar iepriekšējo soli.
Turklāt 5 solī, pēc pēdējā gabala atbrīvošanas, var novērot to, ka atmiņās daudzums samazinās, jo atmiņa tika atgriezta operētājsistēmai. 
Tātad maksimālo kopējo kaudzes izlietošanas problēmu var novērot sekojošā veidā. 

\begin{table}[H]
\caption{\textbf{\fontsize{11}{12}\selectfont {Programmas RSS un VSZ radītāji}}} 
\label{table:kysymys}
\centering
	\begin{tabular}{|l|l|l|p{5cm}|}
	  \hline
	Solis & VSZ & RSS \\
    \hline
    1. Sākums & 3228 & 612 \\
	\hline
	 2. Ar new ir pieprasīti 100 gabali, katrs 100 kilobaitu izmērā  & 13360  & 1136 \\
      \hline
     3. Atmiņa ir aizpildīta ar 0 &  13360 & 10640\\
      \hline
     4. Atmiņa tiek atbrīvota izņemot pēdejo gabalu & 13360 & 10640 \\
      \hline
     5. Atmiņa tiek pilnībā atbrīvota & 3360 & 968 \\
    \hline
	\end{tabular}
\end{table}

\subsection{Maksimālās kopējās kaudzes izlietošanas pazīmes}



\section{Fragmentēšana}
\subsection{Fragmentēšanas pazīmes}

\section{Kļūdas glibc bibliotēkā}
\subsection{glibc kļūdu pazīmes}
